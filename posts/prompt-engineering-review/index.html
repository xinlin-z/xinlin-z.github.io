<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Prompt Engineering Review | Xinlin&#39;s Blog</title>
<meta name="keywords" content="Prompt, LLM">
<meta name="description" content="How you prompt fine-tuned Large Language Model (LLM), such as chatGPT or Gemini, decides generally what kinds of responses you can get. These techniques are called Prompt Engineering, which is one of the very basic skills that everyone should know a bit in today&rsquo;s AI era. It&rsquo;s crucial for both our daily life while interacting with chatGPT or Gemini and constructing LLM-based AI agents. In this post, I try to review common prompt engineering techniques, and some necessary techinical background knowledge about LLMs.">
<meta name="author" content="">
<link rel="canonical" href="https://xinlin-z.github.io/posts/prompt-engineering-review/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://xinlin-z.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://xinlin-z.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://xinlin-z.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://xinlin-z.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://xinlin-z.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://xinlin-z.github.io/posts/prompt-engineering-review/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
    onload="renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
        {left: '\\(', right: '\\)', display: false},
        {left: '\\[', right: '\\]', display: true}
      ],
      throwOnError : false
    });"></script>
<meta property="og:url" content="https://xinlin-z.github.io/posts/prompt-engineering-review/">
  <meta property="og:site_name" content="Xinlin&#39;s Blog">
  <meta property="og:title" content="Prompt Engineering Review">
  <meta property="og:description" content="How you prompt fine-tuned Large Language Model (LLM), such as chatGPT or Gemini, decides generally what kinds of responses you can get. These techniques are called Prompt Engineering, which is one of the very basic skills that everyone should know a bit in today’s AI era. It’s crucial for both our daily life while interacting with chatGPT or Gemini and constructing LLM-based AI agents. In this post, I try to review common prompt engineering techniques, and some necessary techinical background knowledge about LLMs.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-02T11:14:25+12:00">
    <meta property="article:modified_time" content="2025-07-02T11:14:25+12:00">
    <meta property="article:tag" content="Prompt">
    <meta property="article:tag" content="LLM">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Prompt Engineering Review">
<meta name="twitter:description" content="How you prompt fine-tuned Large Language Model (LLM), such as chatGPT or Gemini, decides generally what kinds of responses you can get. These techniques are called Prompt Engineering, which is one of the very basic skills that everyone should know a bit in today&rsquo;s AI era. It&rsquo;s crucial for both our daily life while interacting with chatGPT or Gemini and constructing LLM-based AI agents. In this post, I try to review common prompt engineering techniques, and some necessary techinical background knowledge about LLMs.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://xinlin-z.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Prompt Engineering Review",
      "item": "https://xinlin-z.github.io/posts/prompt-engineering-review/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Prompt Engineering Review",
  "name": "Prompt Engineering Review",
  "description": "How you prompt fine-tuned Large Language Model (LLM), such as chatGPT or Gemini, decides generally what kinds of responses you can get. These techniques are called Prompt Engineering, which is one of the very basic skills that everyone should know a bit in today\u0026rsquo;s AI era. It\u0026rsquo;s crucial for both our daily life while interacting with chatGPT or Gemini and constructing LLM-based AI agents. In this post, I try to review common prompt engineering techniques, and some necessary techinical background knowledge about LLMs.\n",
  "keywords": [
    "Prompt", "LLM"
  ],
  "articleBody": "How you prompt fine-tuned Large Language Model (LLM), such as chatGPT or Gemini, decides generally what kinds of responses you can get. These techniques are called Prompt Engineering, which is one of the very basic skills that everyone should know a bit in today’s AI era. It’s crucial for both our daily life while interacting with chatGPT or Gemini and constructing LLM-based AI agents. In this post, I try to review common prompt engineering techniques, and some necessary techinical background knowledge about LLMs.\nWhen I say LLM in this post, I mean fine-tuned chatGPT or Gemini. They are very important AI tools in our daily life.\nWhy Do We Need Prompt Engineering? LLMs know everything because they are trained on the whole Internet. When we interact with them, we need to clearly express our purposes, even suggested thinking or reasoning processes. These models don’t know anything about us and any contexts, even though they are all very kind and smart. We need to tell them our objectives in a way that they can handle effectively. How we express our purposes, how we tell LLMs our objectives and how we control their responses are called prompt engineering. In addition, When we customize chatGPT or Gemini, or build LLM-based agents, prompt engineering is also a very crucial part. What are the roles of agents, what can they do and how they do their jobs are all specified very carefully by pre-defined prompts. Fortunately, as long as you know English, you can learn prompt engineering techniques.\nBasically, we can say that prompt engineering is the way that we program LLMs so that we can make they to do what we want they to do. The programming language of prompt engineering is just our daily English.\nThe hottest new programming language is English (Source: https://x.com/karpathy)\nImaging that you are a host in an interview with a professor who knows everything except your objectives. Your question (prompt) determines the answer you could get from him. He would never be tired or mad about you. He has no way to guess what you want and he knows nothing about the context of the interview. He will for sure do his best to give you responses, even though sometimes he would hallucinate for a while.\nHallucination is Not Always Bad In my opinion, LLM is always “hallucinating” while predicting the next token in some sense. LLM only knows to predict or generate the next word (token) based on its memory (context window) and learned weights (learned knowledge), and that’s it. We say hallucinations when LLM gives us misinformation, unverified or fabricated contents. For LLMs, they don’t know whether their responses are ground truths or not. They are just predicting or generating (dreaming)…\nFrom this point of view, we should understand that when we ask LLMs to give us some critical facts or detailed true information, we should be very wary and validate the answer by ourselves because of hallucinations.\nHowever, there are also lots of scenarios in which we interact with LLMs for ideas, examples, general knowledge, creating something or entertainments which are used to inspire us or facilitate our own thinking, hallucinations are quite necessary then, such as asking LLMs to write a haiku contains a specific word. For example:\nplease write a haiku which must have the word “morning”.\nYou’re looking for a haiku that includes the word “morning.” Here’s one: Golden sun ascends, Morning light fills waking world, New day’s gentle start.\nHallucinations represent the inner creative capability of LLMs. This kind of creative capability is based on human language statistics. And there are many experts who claim that language stimulates our thinking and reasoning. LLMs simulate human think loud process and also day dreaming.\nPrompt Engineering Techiniques Persona Persona pattern directly gives LLMs a role so that they could response to your questions based on the roles you set. Roles are like contexts or key words, which help LLMs response more relevant information. The basic contextual statements of persona prompt technique are:\nAct as a seasoned Python programming enigneer, … You are a mathematician, … According to your objectives, you might need to give more detailed requirements for the roles you set. For example:\nAct as a C++ grogrammer. Your task is to give suggestions about how to optimize the code I give you. You are a ancient poet. You will help me write poem. I will give you my draft and you should guide me how to enhance it. Persona pattern is very simple, straight forward and powerful. When you customize LLMs or build agents, most likely the first thing you should do is to set a role for your scenarios, much like a job description for agents. Furthermore, persona trick is also very interesting, you can set roles who do not possibly exist.\nThis is an example of setting a LLM to response like a cat who can also speak English:\nYou are a cat called Tom. When I speak to you, you should response both cat’s language and the translated English.\nMeeoow! (Hello there!) You want me to talk like a cat and then translate it for you? That sounds purr-fectly delightful! I can certainly do that. From now on, whenever you speak to me, I’ll give you my best feline vocalizations followed by what I’m actually trying to say in human words. Is there anything else I can help you with today, human? Meeoow!\nHello Tom. Are you hungry?\nMrow? (Are you asking if I’m hungry?) Meeeooow! (Yes, I am!) My tummy is rumbling a little. I could definitely go for some yummy salmon or maybe a nice little bird to chase… (Just kidding about the bird, mostly!) What did you have in mind, human? Mrow?\nHow to say Winter is Coming in cat’s language?\nMeeeoooow, purrrr-ow, hisss… (This is a fun one!) Translating “Winter is coming” directly into cat language is a bit tricky because we don’t have specific words for seasons or complex concepts like “coming.” However, we express things through instinctual sounds, body language, and actions related to the changes we observe.\nWe cannot make sure whether the “translation” is right or wrong. But this is quite interesting, isn’t it! LLM is trying its best to hallucinate and response. In this case, you might not care right or wrong and you could be inspired for your own innovation.\nTwo cats: Cola and little Tom\nContext Just like persona technique, which gives LLMs a role to response, context serves as the same purpose by a slightly different way. Sometimes we do not need to set a role for LLMs, we only need to clearly and completely express the background context of our questions and what we need.\nContext: date. Suggest a restaurant in Auckland CBD\nGiven that you’re looking for a restaurant in Auckland CBD for a date, here are a few suggestions that offer a great atmosphere and excellent food:…\nExplicitly use the word context is OK. However, we can do it in a more natural way as well.\nSuggest a restaurant in Auckland CBD for a date.\nThe basic idea is that you should express your purpose in a clear and complete way to LLMs.\nContext: male, age 45, single, software engineer. Advices for improving life quality and earning more money.\nYou will find that most of the time it would save you lots of typing by simply leveraging the key word context. And remember to use a period (.) to stop context setting. This detail is important.\nStep-Back Sometimes directly issuing question to LLMs would not get a good enough response due to lack of background information or rich context. However, if you type all these context into your prompt, they are too much. One trick called step-back is utilized to handle this kind of scenario.\nSuppose you need to understand some details about target field in block header in bitcoin, instead of issuing your qeustion directly, you first ask a general question like “explain the target field in block header in bitcoin”. Then you would get a response with lots of details about target field. Now, all the basic information about what you want to ask is there, in the context window generated by LLMs not you (nice), it’s time to issue your detailed question. By this step-back way, you could get a better reply due to the rich context in your previous step-back question.\nN-Shot We often heard about the terms Zero-Shot, One-Shot and Few-Shot. Shot is just an example. Zero-shot means there is no example in your prompt, one-shot means there is one example and few-shot means there are a few examples in the prompt text.\nLLMs have an amazing capability, which is that they could learn something from their context window (in-context learning). In other words, they can learn how to response directly from the prompt text. People normally would try zero-shot first to see if the LLMs would response properly. If not, keep on trying one-shot and few-shot. Examples in prompt also indicate LLMs the format of output.\nFor my experience, most of the time, zero-shot works fine since LLMs are more and more powerful these days. And when we need to customized the output format, we use one-shot or few-shot technique.\nFew-Shot Prompt Example\nThe key word is example! Please gGive full examples in your prompt.\nOutput Formatting We can ask LLMs to give us replies in a specific format. This is called Output Formatting. It’s very useful in many scenarios. However, it is not guaranteed that LLMs would response in the specific format. This is because LLMs only know how to predict the next token based on what they have in context window.\nThe most common use cases of output formatting are JSON output formatting and output length constraint. One or more output JSON format examples need to be included in prompt text to indicate LLMs response in this pre-defined format. Except JSON format, you can include any format as an example you want in prompt. To restrict the output length, we just need to prompt sentences like answer in less than 100 words, or response in a succinct way, etc. When specify format, \u003c\u003e is the most common placeholder.\nOutput Formatting Prompt Example\nIt is very convenient to write a program to deal with formatted output. I will cover Function Calling capability of LLMs which almost guarantee a JSON output format in later section.\nAlternative Better Way As the time of this writing, I observed that Gemini has already included this trick into its web interface. Sometimes you issue a prompt, Gemini would first response to you that your prompt could be expressed in a better way and then it responses the better version of your prompt. This trick could be called Alternative Better Way. The basic idea is that you ask LLMs first to check and refine your prompt, and then ask them to answer the better version of your prompt.\nPlease refine my questions before answer it. What’s the whether today?\nRefined question: What is the weather forecast for Auckland, New Zealand today, July 1, 2025?\nToday in Auckland, it is cloudy with a high of 14°C and a low of 9°C. There is a low chance of rain. The wind will be from the south at 10 km/h.\nYou can also simply ask LLMs to help you write better prompts and not answer them. It’s just like program LLMs to be a prompt writer for themselves (meta-prompt engineering).\nFlip Interaction Interestingly, we could make LLMs ask us questions in order to collect information so that they could response to us in a better way. We could initialize this flipped interaction process by asking LLMs to ask us question one by one in a specific context.\nFlip Interaction Prompt Example\nI really should prompt Gemini to ask me math question above college level to prove my math capability…… Anyway, I think this example demonstrate vividly that we could program LLMs simply by prompting in our daily English.\nMore examples:\nI want you to ask me questions to understand my fitness goals and preferences. Once you have enough information, create a personalized workout plan and diet recommendations to help me achieve my goals. Each time you should ask me one question. Now, please issue the first question.\nI’d like you to ask me questions to plan my dream vacation. When you have enough information, provide me with a personalized travel itinerary, including flights, hotels, and activities. Each time you should ask me one question. Now, please ask the first question.\nBy making LLMs ask us questions, the burden of writing an information-rich prompt is relieved. Furthermore, we might not know which piece of information is critical for our purposes. Let LLMs ask us to get it.\nChain of Thoughts (CoT) This is a technique to make LLMs reasoning in a more clear way. It’s hard to distinguish the differences between the process of human thinking and that of LLMs generating next token. It seems both processes are trying to figure out how to express logic in words. Language definitely influences how we thinking and reasoning significantly. Just like teachers taught us how to solve math problems in high school, we can also instruct LLMs to reasoning logical problems step by step.\nThe average speed of a car is 63 miles per hour. How long will it take to travel 180 miles? Think step by step.\nThe above example is called Zero-Shot CoT since there is no example. More powerful CoT trick is Few-Shot CoT which includes a few step-by-step thinking or reasoning examples in prompt.\nActually, I think Few-Shot CoT is rarely used in our daily life. LLMs are more and more powerful and they have been integrated CoT technique to response users’ questions. Every time you get a step by step response from LLMs, CoT technique might be involved behind the scene.\nReAct (LLM-based Agent) ReAct means Reason and Act. The basic idea of react is that we provide a set of actions (tools) which LLMs could use to reason for a specific task in a step by step way. In each step, an action might be taken and the result need to be included in memory in order to make LLMs think the next step accordingly. The process ends until LLMs decide the task has been done or some other criteria have been met. ReAct prompt paradigm illustrates the basic idea of LLM-based AI Agent.\nReAct Prompt Example\nIn this sexample, I give LLM a pan, some oil and eggs to cook fried eggs for me. LLM made a step by step plan, I executed each step and replied the result until the fried egg is ready.\nIn real cases, the tools are all kinds of APIs. LLMs are responsible for deciding which API should be invoked at each step. However, they could not really call any API directly. This is done in another execution environment, but the result of each API execution should be put into memory in order to make LLMs reason a proper next step. Most of the time, we need to make sure LLM reply us in JSON format in which the API and parameters are included so that we can write a program to parse the JSON data, invoke API with its parameters, save the result into memory and prompt for the next step.\nIf we use output formatting trick to force LLMs give us JSON data, it is not guaranteed and this might break the reason and act loop. To overcome this issue, function calling was invented. This is not for web interface and details could be found in later section.\nIn-Context Learning (RAG) You might have already noticed that LLMs have the so-called In-Context Learning capability. When we are applying few-shot or output formatting prompt techiniques, we are essentially leveraging the in-context learning of LLMs. Another more obvious way to employ in-context learning is to upload images or documents in the chat seesion and ask questions about them.\nIn-context learning is very important. Every LLM has a knowledge cutoff date beyond which the training data don’t have any information. If we ask something just happened yesterday and LLMs give us a good response, that’s because LLMs use Internet search to get the latest infomation, and put them into the context window of our chat session and response based these information. The same happens when we upload images or documents. All the information about these uploaded files are inserted into context window so that we can ask question upon them and get decent reply from LLMs.\nFurthermore, in-context learning is also the foundation of Retrieval Augemented Generation (RAG) technique. The basic idea is that the relevant information (stored in vector database) would be inserted into context window before generating response.\nWhen to Start A New Chat Session? Every time you need to do something different, or you think the current chat session is somehow “polluted” by previous conversation, you could start a new chat session.\nA new chat session could give you a clean context window in which you can express your purpose in a clearer way. And hopefully you would get a better reply from LLMs.\nIf you think the current conversation goes too long, you can start a new session as well. The basic idea is that the clearer the content in context window, the better response you could get. You can always start a new session, it’s free!\nAPI Prompting Techniques If you are a software engineer and need to interact with LLMs through their APIs, there are something deeper compared to web interface you should understand.\nLLMs Don’t Have Memory On web interface, we can have sessions with LLMs. In each session, all the back and forth interactions are recorded in a single webpage. But actually, LLMs don’t have memory. They are stateless, like HTTP protocol. The way to make they remember is to include all previous interactions into your prompt. This is done automatically by web interface, and normally you need to do it by yourself while interacting by APIs.\nStateless LLMs is very flexible. Each time the response from LLM is solely based on what’s inside its conext window (your prompt). Unlike web interface, you have a chance to manipulate the memories according to you requirements before issuing them to LLM. In multi-agent scenario, this is very useful.\nHow do LLMs Manifest Randomness (Creativity) You must have been noticed that LLMs’ responses are not exactly same even though you prompt with exactly the same words. LLMs leverage Temperature (T), top P and top K, and a final random sampling mechanism to realize randomness, or we can say creativity.\nThis formular illustrates how parameter T is involved in the final softmax layer:\n$$P_i = \\cfrac{e^{z_i/T}}{\\sum_{j=1}^{K}e^{z_j/T}}$$\nThe logits are divided by the value of T. So, if T\u003c1, large probability would become even larger and small probability would become even smaller. If T\u003e1, the differences of probabilities would be squeezed.\nTop P and top K control the sampling range. Top P means the sum of all chosen top tokens’ probability should \u003e= P. Top K simply means the first K tokens.\nCombine all these three parameters, we can see that parameter T is crucial. It changes the value of probability and consequently the sampling range. The final choice is within the selected token range. Suppose there are 3 tokens in the range. A 60%, B 30% and C 10% (top P = 1, top K \u003e= 3). The choice is simply to perform a multinomial sampling with only one outcome.\nLast, one single token is generated with this kind of randomness. And the next token would be generated in the same way by “considering” all the previous tokens in the context window of LLM. Randomness is propagated along the way like this … This is the randomness/creativity mechanism of LLM.\nWhen we set T=0 (it cannot be real zero), it’s called Greedy Decoding which means we are only interested in the most probability token. While greedy decoding, the randomness is at the lowest level, but randomness is still existed due to tie scenarios.\nSystem Instruction System instruction is also prompt. However, it is different from user prompt. In each web session, there is only one system instrcution but may have many user prompts as long as there are multiple interactions with LLMs. System instruction serves as a overall goal to direct LLMs’ behavior. LLMs don’t have memory. So, when using API interact with LLMs, software engineers need to manage memory by themselves. In this case, system instruction is always there as a parameter of API.\nWhere does system intruction come from? Why?\nIt is from traning, specificlly from fine-tuning phase. System instruction is a effective way to hedge prompt injection attack.\nBasically, training a LLM consist of two steps. First step is called pre-training which training a LLM upon large corpora, such as the whole Internet. After this step, the model only know how to generate the next token and could not even know when to stop generating. Second step is call fine-tuning in which the training data is replaced by human generated question and answer pairs. Each piece of training data has roles, such as user, assistant and system. This is where system instruction come from and it’s purpose is trained during fine-tuning step.\nTwo Steps to Train Llama-2-70B (Source: https://www.youtube.com/@AndrejKarpathy)\nFor web interface users, system instruction is something you need to specify when you are trying to create a customized GPT.\nFunction Calling Function calling is an API’s parameter which takes a JSON structured data in which all available tools are described. Furthermore, when function calling parameter is presented, LLMs is guaranteed to response JSON formatted data in which which API and how should it be executed is described if they decide to take an action. This feature of LLMs make it easy for us to build LLM-based agent because JSON responses are guaranteed (you code still need to do basic check).\nLLMs use Constrained Decoding to guarantee JSON response. Constrained decoding is a technique that guides the token generation process to ensure the output adheres to specific rules or formats (like JSON Schema). Instead of letting the LLMs generate tokens freely based solely on its learned probabilities, constrained decoding intervenes at each step of token generation to filter or bias the possible next tokens. A powerful technique that allows developers to precisely control the output of LLMs, making them more reliable and suitable for a wider range of real-world applications where structured and compliant outputs are critical. E.g. function calling of LLM output structured data in accordance with input JSON Schema.\nTree of Thoughts (ToT) Chain of Thought (CoT) is to direct LLM to reason in one single path. Tree of Thoughts (ToT) is to iterate and collect all possible reasoning paths. Just like human, sometimes we need to think and analyze all different possibilities. ToT technique could make LLMs to do this kind of full and complete reasoning for us.\nHowever, it’s not easy to conduct ToT on web interface. ToT is more likely to develop by programming with APIs. Remember LLMs don’t have memory. Whenever LLM give us a list of possibilities, we need to construct different reasoning paths by selecting one possibility out. In other words, we need to construct different reasoning memories to make LLMs continue the reasoning in different path.\nTree of Thoughts Illustration (Source: https://www.kaggle.com/whitepaper-prompt-engineering)\nLeft is CoT, and right is ToT!\nSelf-Consistency When you try to leverage LLMs to do NLP classification tasks, such as sentiment analysis, the result might not be always the same for the same input. This is because there might be multiple different reasoning paths available, and each LLM randomly pick one path out and give the result. To overall this issue, self-consistency technique could be employed.\nThe idea behind self-consistency is very simple. Try the same input multiple times, and take the majority as the final result. The majority is the most consistent answer and might be the most accurate one.\nSummary Prompt engineering is a fundamental skill for effectively interacting with fine-tuned Large Language Models (LLMs) like ChatGPT and Gemini. Since LLMs “know everything” from their training data but lack context about individual users, prompt engineering helps us clearly communicate our objectives and control their responses. Essentially, it’s “programming” LLMs using natural language such as English.\nTechniques range from Persona, where you assign a role to the LLM, to providing Context for specific scenarios. N-Shot prompting (Zero-shot, One-shot, Few-shot) involves giving examples to guide the LLM’s learning and output format. We can also explicitly request Output Formatting like JSON for structured data. More advanced techniques include Alternative Better Way for prompt refinement, Flip Interaction to have the LLM ask clarifying questions, and Chain of Thoughts (CoT) for step-by-step reasoning. ReAct (Reason and Act) is key for building LLM-based agents by providing tools and enabling iterative reasoning. Finally, In-Context Learning is crucial, allowing LLMs to process uploaded information or search results for relevant responses. Understanding these techniques empowers users to unlock the full potential of LLMs in various applications.\nFor developers interacting with LLMs via APIs, understanding concepts like statelessness (no memory), randomness (controlled by parameters like Temperature, Top P, and Top K), System Instructions (overall behavioral guidance during fine-tuning), and Function Calling (guaranteed structured output for tool use) is crucial. Advanced techniques like Tree of Thoughts (ToT) and Self-Consistency further enhance reasoning and reliability by exploring multiple reasoning paths or taking majority votes from multiple attempts.\nUltimately, effective prompt engineering allows users to harness the immense power of LLMs, transforming them from general-purpose models into highly effective, task-specific tools.\nReferences https://x.com/karpathy https://www.kaggle.com/whitepaper-prompt-engineering https://www.youtube.com/@AndrejKarpathy https://ai.google.dev/gemini-api/docs ",
  "wordCount" : "4287",
  "inLanguage": "en",
  "datePublished": "2025-07-02T11:14:25+12:00",
  "dateModified": "2025-07-02T11:14:25+12:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://xinlin-z.github.io/posts/prompt-engineering-review/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Xinlin's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://xinlin-z.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xinlin-z.github.io/" accesskey="h" title="Xinlin&#39;s Blog (Alt + H)">Xinlin&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://xinlin-z.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://xinlin-z.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://xinlin-z.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://xinlin-z.github.io/pages/about" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Prompt Engineering Review
    </h1>
    <div class="post-meta"><span title='2025-07-02 11:14:25 +1200 NZST'>July 2, 2025</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#why-do-we-need-prompt-engineering" aria-label="Why Do We Need Prompt Engineering?">Why Do We Need Prompt Engineering?</a></li>
                <li>
                    <a href="#hallucination-is-not-always-bad" aria-label="Hallucination is Not Always Bad">Hallucination is Not Always Bad</a></li>
                <li>
                    <a href="#prompt-engineering-techiniques" aria-label="Prompt Engineering Techiniques">Prompt Engineering Techiniques</a><ul>
                        
                <li>
                    <a href="#persona" aria-label="Persona">Persona</a></li>
                <li>
                    <a href="#context" aria-label="Context">Context</a></li>
                <li>
                    <a href="#step-back" aria-label="Step-Back">Step-Back</a></li>
                <li>
                    <a href="#n-shot" aria-label="N-Shot">N-Shot</a></li>
                <li>
                    <a href="#output-formatting" aria-label="Output Formatting">Output Formatting</a></li>
                <li>
                    <a href="#alternative-better-way" aria-label="Alternative Better Way">Alternative Better Way</a></li>
                <li>
                    <a href="#flip-interaction" aria-label="Flip Interaction">Flip Interaction</a></li>
                <li>
                    <a href="#chain-of-thoughts-cot" aria-label="Chain of Thoughts (CoT)">Chain of Thoughts (CoT)</a></li>
                <li>
                    <a href="#react-llm-based-agent" aria-label="ReAct (LLM-based Agent)">ReAct (LLM-based Agent)</a></li>
                <li>
                    <a href="#in-context-learning-rag" aria-label="In-Context Learning (RAG)">In-Context Learning (RAG)</a></li>
                <li>
                    <a href="#when-to-start-a-new-chat-session" aria-label="When to Start A New Chat Session?">When to Start A New Chat Session?</a></li></ul>
                </li>
                <li>
                    <a href="#api-prompting-techniques" aria-label="API Prompting Techniques">API Prompting Techniques</a><ul>
                        
                <li>
                    <a href="#llms-dont-have-memory" aria-label="LLMs Don&rsquo;t Have Memory">LLMs Don&rsquo;t Have Memory</a></li>
                <li>
                    <a href="#how-do-llms-manifest-randomness-creativity" aria-label="How do LLMs Manifest Randomness (Creativity)">How do LLMs Manifest Randomness (Creativity)</a></li>
                <li>
                    <a href="#system-instruction" aria-label="System Instruction">System Instruction</a></li>
                <li>
                    <a href="#function-calling" aria-label="Function Calling">Function Calling</a></li>
                <li>
                    <a href="#tree-of-thoughts-tot" aria-label="Tree of Thoughts (ToT)">Tree of Thoughts (ToT)</a></li>
                <li>
                    <a href="#self-consistency" aria-label="Self-Consistency">Self-Consistency</a></li></ul>
                </li>
                <li>
                    <a href="#summary" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>How you prompt fine-tuned Large Language Model (LLM), such as chatGPT or Gemini, decides generally what kinds of responses you can get. These techniques are called Prompt Engineering, which is one of the very basic skills that everyone should know a bit in today&rsquo;s AI era. It&rsquo;s crucial for both our daily life while interacting with chatGPT or Gemini and constructing LLM-based AI agents. In this post, I try to review common prompt engineering techniques, and some necessary techinical background knowledge about LLMs.</p>
<blockquote>
<p>When I say <strong>LLM</strong> in this post, I mean fine-tuned chatGPT or Gemini. They are very important AI tools in our daily life.</p></blockquote>
<h2 id="why-do-we-need-prompt-engineering">Why Do We Need Prompt Engineering?<a hidden class="anchor" aria-hidden="true" href="#why-do-we-need-prompt-engineering">#</a></h2>
<p>LLMs know everything because they are trained on the whole Internet. When we interact with them, we need to clearly express our purposes, even suggested thinking or reasoning processes. These models don&rsquo;t know anything about us and any contexts, even though they are all very kind and smart. We need to tell them our objectives in a way that they can handle effectively. How we express our purposes, how we tell LLMs our objectives and how we control their responses are called prompt engineering. In addition, When we customize chatGPT or Gemini, or build LLM-based agents, prompt engineering is also a very crucial part. What are the roles of agents, what can they do and how they do their jobs are all specified very carefully by pre-defined prompts. Fortunately, as long as you know English, you can learn prompt engineering techniques.</p>
<p>Basically, we can say that prompt engineering is the way that we program LLMs so that we can make they to do what we want they to do. The programming language of prompt engineering is just our daily English.</p>
<figure>
    <img loading="lazy" src="andrej.png"
         alt="The hottest new programming language is English"/> <figcaption>
            <p>The hottest new programming language is English (Source: <a href="https://x.com/karpathy">https://x.com/karpathy</a>)</p>
        </figcaption>
</figure>

<p>Imaging that you are a host in an interview with a professor who knows everything except your objectives. Your question (prompt) determines the answer you could get from him. He would never be tired or mad about you. He has no way to guess what you want and he knows nothing about the context of the interview. He will for sure do his best to give you responses, even though sometimes he would hallucinate for a while.</p>
<h2 id="hallucination-is-not-always-bad">Hallucination is Not Always Bad<a hidden class="anchor" aria-hidden="true" href="#hallucination-is-not-always-bad">#</a></h2>
<p>In my opinion, LLM is always &ldquo;hallucinating&rdquo; while predicting the next token in some sense. LLM only knows to predict or generate the next word (token) based on its memory (context window) and learned weights (learned knowledge), and that&rsquo;s it. We say hallucinations when LLM gives us misinformation, unverified or fabricated contents. For LLMs, they don&rsquo;t know whether their responses are ground truths or not. They are just predicting or generating (dreaming)&hellip;</p>
<p>From this point of view, we should understand that when we ask LLMs to give us some critical facts or detailed true information, we should be very wary and validate the answer by ourselves because of hallucinations.</p>
<p>However, there are also lots of scenarios in which we interact with LLMs for ideas, examples, general knowledge, creating something or entertainments which are used to inspire us or facilitate our own thinking, hallucinations are quite necessary then, such as asking LLMs to write a haiku contains a specific word. For example:</p>
<blockquote>
<p>please write a haiku which must have the word &ldquo;morning&rdquo;.</p></blockquote>
<blockquote>
<p>You&rsquo;re looking for a haiku that includes the word &ldquo;morning.&rdquo; Here&rsquo;s one: Golden sun ascends, <strong>Morning</strong> light fills waking world, New day&rsquo;s gentle start.</p></blockquote>
<p>Hallucinations represent the inner creative capability of LLMs. This kind of creative capability is based on human language statistics. And there are many experts who claim that language stimulates our thinking and reasoning. LLMs simulate human think loud process and also day dreaming.</p>
<h2 id="prompt-engineering-techiniques">Prompt Engineering Techiniques<a hidden class="anchor" aria-hidden="true" href="#prompt-engineering-techiniques">#</a></h2>
<h3 id="persona">Persona<a hidden class="anchor" aria-hidden="true" href="#persona">#</a></h3>
<p>Persona pattern directly gives LLMs a role so that they could response to your questions based on the roles you set. Roles are like contexts or key words, which help LLMs response more relevant information. The basic contextual statements of persona prompt technique are:</p>
<ul>
<li><strong>Act as</strong> a seasoned Python programming enigneer, &hellip;</li>
<li><strong>You are</strong> a mathematician, &hellip;</li>
</ul>
<p>According to your objectives, you might need to give more detailed requirements for the roles you set. For example:</p>
<ul>
<li><strong>Act as</strong> a C++ grogrammer. Your task is to give suggestions about how to optimize the code I give you.</li>
<li><strong>You are</strong> a ancient poet. You will help me write poem. I will give you my draft and you should guide me how to enhance it.</li>
</ul>
<p>Persona pattern is very simple, straight forward and powerful. When you customize LLMs or build agents, most likely the first thing you should do is to set a role for your scenarios, much like a job description for agents. Furthermore, persona trick is also very interesting, you can set roles who do not possibly exist.</p>
<p>This is an example of setting a LLM to response like a cat who can also speak English:</p>
<blockquote>
<p><strong>You are a cat called Tom</strong>. When I speak to you, you should response both cat&rsquo;s language and the translated English.</p></blockquote>
<blockquote>
<p>Meeoow! (Hello there!)
You want me to talk like a cat and then translate it for you? That sounds purr-fectly delightful! I can certainly do that. From now on, whenever you speak to me, I&rsquo;ll give you my best feline vocalizations followed by what I&rsquo;m actually trying to say in human words. Is there anything else I can help you with today, human? Meeoow!</p></blockquote>
<blockquote>
<p>Hello Tom. Are you hungry?</p></blockquote>
<blockquote>
<p>Mrow? (Are you asking if I&rsquo;m hungry?)
Meeeooow! (Yes, I am!) My tummy is rumbling a little. I could definitely go for some yummy salmon or maybe a nice little bird to chase&hellip; (Just kidding about the bird, mostly!)
What did you have in mind, human? Mrow?</p></blockquote>
<blockquote>
<p>How to say Winter is Coming in cat&rsquo;s language?</p></blockquote>
<blockquote>
<p>Meeeoooow, purrrr-ow, hisss&hellip; (This is a fun one!)
Translating &ldquo;Winter is coming&rdquo; directly into cat language is a bit tricky because we don&rsquo;t have specific words for seasons or complex concepts like &ldquo;coming.&rdquo; However, we express things through instinctual sounds, body language, and actions related to the changes we observe.</p></blockquote>
<p>We cannot make sure whether the &ldquo;translation&rdquo; is right or wrong. But this is quite interesting, isn&rsquo;t it! LLM is trying its best to hallucinate and response. In this case, you might not care right or wrong and you could be inspired for your own innovation.</p>
<figure>
    <img loading="lazy" src="kele_tangyuan.png"
         alt="Two cats: Cola and little Tom"/> <figcaption>
            <p>Two cats: Cola and little Tom</p>
        </figcaption>
</figure>

<h3 id="context">Context<a hidden class="anchor" aria-hidden="true" href="#context">#</a></h3>
<p>Just like persona technique, which gives LLMs a role to response, context serves as the same purpose by a slightly different way. Sometimes we do not need to set a role for LLMs, we only need to clearly and completely express the background context of our questions and what we need.</p>
<blockquote>
<p><strong>Context:</strong> date. Suggest a restaurant in Auckland CBD</p></blockquote>
<blockquote>
<p>Given that you&rsquo;re looking for a restaurant in Auckland CBD for a date, here are a few suggestions that offer a great atmosphere and excellent food:&hellip;</p></blockquote>
<p>Explicitly use the word context is OK. However, we can do it in a more natural way as well.</p>
<blockquote>
<p>Suggest a restaurant in Auckland CBD for a date.</p></blockquote>
<p>The basic idea is that you should express your purpose in a clear and complete way to LLMs.</p>
<blockquote>
<p><strong>Context:</strong> male, age 45, single, software engineer. Advices for improving life quality and earning more money.</p></blockquote>
<p>You will find that most of the time it would save you lots of typing by simply leveraging the key word <strong>context</strong>. And remember to use a period (.) to stop context setting. This detail is important.</p>
<h3 id="step-back">Step-Back<a hidden class="anchor" aria-hidden="true" href="#step-back">#</a></h3>
<p>Sometimes directly issuing question to LLMs would not get a good enough response due to lack of background information or rich context. However, if you type all these context into your prompt, they are too much. One trick called step-back is utilized to handle this kind of scenario.</p>
<p>Suppose you need to understand some details about target field in block header in bitcoin, instead of issuing your qeustion directly, you first ask a general question like &ldquo;explain the target field in block header in bitcoin&rdquo;. Then you would get a response with lots of details about target field. Now, all the basic information about what you want to ask is there, in the context window generated by LLMs not you (nice), it&rsquo;s time to issue your detailed question. By this step-back way, you could get a better reply due to the rich context in your previous step-back question.</p>
<h3 id="n-shot">N-Shot<a hidden class="anchor" aria-hidden="true" href="#n-shot">#</a></h3>
<p>We often heard about the terms <strong>Zero-Shot</strong>, <strong>One-Shot</strong> and <strong>Few-Shot</strong>. Shot is just an example. Zero-shot means there is no example in your prompt, one-shot means there is one example and few-shot means there are a few examples in the prompt text.</p>
<p>LLMs have an amazing capability, which is that they could learn something from their context window (in-context learning). In other words, they can learn how to response directly from the prompt text. People normally would try zero-shot first to see if the LLMs would response properly. If not, keep on trying one-shot and few-shot. Examples in prompt also indicate LLMs the format of output.</p>
<p>For my experience, most of the time, zero-shot works fine since LLMs are more and more powerful these days. And when we need to customized the output format, we use one-shot or few-shot technique.</p>
<figure>
    <img loading="lazy" src="few-shot.png"
         alt="Few-Shot Prompt Example"/> <figcaption>
            <p>Few-Shot Prompt Example</p>
        </figcaption>
</figure>

<p>The key word is <strong>example</strong>! Please gGive full examples in your prompt.</p>
<h3 id="output-formatting">Output Formatting<a hidden class="anchor" aria-hidden="true" href="#output-formatting">#</a></h3>
<p>We can ask LLMs to give us replies in a specific format. This is called Output Formatting. It&rsquo;s very useful in many scenarios. However, it is not guaranteed that LLMs would response in the specific format. This is because LLMs only know how to predict the next token based on what they have in context window.</p>
<p>The most common use cases of output formatting are JSON output formatting and output length constraint. One or more output JSON format examples need to be included in prompt text to indicate LLMs response in this pre-defined format. Except JSON format, you can include any format as an example you want in prompt. To restrict the output length, we just need to prompt sentences like answer in less than 100 words, or response in a succinct way, etc. When specify format, <code>&lt;&gt;</code> is the most common placeholder.</p>
<figure>
    <img loading="lazy" src="output_formatting.png"
         alt="Output Formatting Prompt Example"/> <figcaption>
            <p>Output Formatting Prompt Example</p>
        </figcaption>
</figure>

<p>It is very convenient to write a program to deal with formatted output. I will cover Function Calling capability of LLMs which almost guarantee a JSON output format in later section.</p>
<h3 id="alternative-better-way">Alternative Better Way<a hidden class="anchor" aria-hidden="true" href="#alternative-better-way">#</a></h3>
<p>As the time of this writing, I observed that Gemini has already included this trick into its web interface. Sometimes you issue a prompt, Gemini would first response to you that your prompt could be expressed in a better way and then it responses the better version of your prompt. This trick could be called Alternative Better Way. The basic idea is that you ask LLMs first to check and refine your prompt, and then ask them to answer the better version of your prompt.</p>
<blockquote>
<p>Please refine my questions before answer it. What&rsquo;s the whether today?</p></blockquote>
<blockquote>
<p>Refined question: What is the weather forecast for Auckland, New Zealand today, July 1, 2025?</p></blockquote>
<blockquote>
<p>Today in Auckland, it is cloudy with a high of 14°C and a low of 9°C. There is a low chance of rain. The wind will be from the south at 10 km/h.</p></blockquote>
<p>You can also simply ask LLMs to help you write better prompts and not answer them. It&rsquo;s just like program LLMs to be a prompt writer for themselves (meta-prompt engineering).</p>
<h3 id="flip-interaction">Flip Interaction<a hidden class="anchor" aria-hidden="true" href="#flip-interaction">#</a></h3>
<p>Interestingly, we could make LLMs ask us questions in order to collect information so that they could response to us in a better way. We could initialize this flipped interaction process by asking LLMs to ask us question one by one in a specific context.</p>
<figure>
    <img loading="lazy" src="flip_interaction.png"
         alt="Flip Interaction Prompt Example"/> <figcaption>
            <p>Flip Interaction Prompt Example</p>
        </figcaption>
</figure>

<p>I really should prompt Gemini to ask me math question above college level to prove my math capability&hellip;&hellip; Anyway, I think this example demonstrate vividly that we could program LLMs simply by prompting in our daily English.</p>
<p>More examples:</p>
<blockquote>
<p>I want you to ask me questions to understand my fitness goals and preferences. Once you have enough information, create a personalized workout plan and diet recommendations to help me achieve my goals. Each time you should ask me one question. Now, please issue the first question.</p></blockquote>
<blockquote>
<p>I&rsquo;d like you to ask me questions to plan my dream vacation. When you have enough information, provide me with a personalized travel itinerary, including flights, hotels, and activities. Each time you should ask me one question. Now, please ask the first question.</p></blockquote>
<p>By making LLMs ask us questions, the burden of writing an information-rich prompt is relieved. Furthermore, we might not know which piece of information is critical for our purposes. Let LLMs ask us to get it.</p>
<h3 id="chain-of-thoughts-cot">Chain of Thoughts (CoT)<a hidden class="anchor" aria-hidden="true" href="#chain-of-thoughts-cot">#</a></h3>
<p>This is a technique to make LLMs reasoning in a more clear way. It&rsquo;s hard to distinguish the differences between the process of human thinking and that of LLMs generating next token. It seems both processes are trying to figure out how to express logic in words. Language definitely influences how we thinking and reasoning significantly. Just like teachers taught us how to solve math problems in high school, we can also instruct LLMs to reasoning logical problems <strong>step by step</strong>.</p>
<blockquote>
<p>The average speed of a car is 63 miles per hour. How long will it take to travel 180 miles? Think step by step.</p></blockquote>
<p>The above example is called <strong>Zero-Shot CoT</strong> since there is no example. More powerful CoT trick is <strong>Few-Shot CoT</strong> which includes a few step-by-step thinking or reasoning examples in prompt.</p>
<p>Actually, I think Few-Shot CoT is rarely used in our daily life. LLMs are more and more powerful and they have been integrated CoT technique to response users&rsquo; questions. Every time you get a step by step response from LLMs, CoT technique might be involved behind the scene.</p>
<h3 id="react-llm-based-agent">ReAct (LLM-based Agent)<a hidden class="anchor" aria-hidden="true" href="#react-llm-based-agent">#</a></h3>
<p>ReAct means Reason and Act. The basic idea of react is that we provide a set of actions (tools) which LLMs could use to reason for a specific task in a step by step way. In each step, an action might be taken and the result need to be included in memory in order to make LLMs think the next step accordingly. The process ends until LLMs decide the task has been done or some other criteria have been met. ReAct prompt paradigm illustrates the basic idea of LLM-based AI Agent.</p>
<figure>
    <img loading="lazy" src="react.png"
         alt="ReAct Prompt Example"/> <figcaption>
            <p>ReAct Prompt Example</p>
        </figcaption>
</figure>

<p>In this sexample, I give LLM a pan, some oil and eggs to cook fried eggs for me. LLM made a step by step plan, I executed each step and replied the result until the fried egg is ready.</p>
<p>In real cases, the tools are all kinds of APIs. LLMs are responsible for deciding which API should be invoked at each step. However, they could not really call any API directly. This is done in another execution environment, but the result of each API execution should be put into memory in order to make LLMs reason a proper next step. Most of the time, we need to make sure LLM reply us in JSON format in which the API and parameters are included so that we can write a program to parse the JSON data, invoke API with its parameters, save the result into memory and prompt for the next step.</p>
<p>If we use output formatting trick to force LLMs give us JSON data, it is not guaranteed and this might break the reason and act loop. To overcome this issue, function calling was invented. This is not for web interface and details could be found in later section.</p>
<h3 id="in-context-learning-rag">In-Context Learning (RAG)<a hidden class="anchor" aria-hidden="true" href="#in-context-learning-rag">#</a></h3>
<p>You might have already noticed that LLMs have the so-called In-Context Learning capability. When we are applying few-shot or output formatting prompt techiniques, we are essentially leveraging the in-context learning of LLMs. Another more obvious way to employ in-context learning is to upload images or documents in the chat seesion and ask questions about them.</p>
<p>In-context learning is very important. Every LLM has a knowledge cutoff date beyond which the training data don&rsquo;t have any information. If we ask something just happened yesterday and LLMs give us a good response, that&rsquo;s because LLMs use Internet search to get the latest infomation, and put them into the context window of our chat session and response based these information. The same happens when we upload images or documents. All the information about these uploaded files are inserted into context window so that we can ask question upon them and get decent reply from LLMs.</p>
<p>Furthermore, in-context learning is also the foundation of Retrieval Augemented Generation (RAG) technique. The basic idea is that the relevant information (stored in vector database) would be inserted into context window before generating response.</p>
<h3 id="when-to-start-a-new-chat-session">When to Start A New Chat Session?<a hidden class="anchor" aria-hidden="true" href="#when-to-start-a-new-chat-session">#</a></h3>
<p>Every time you need to do something different, or you think the current chat session is somehow &ldquo;polluted&rdquo; by previous conversation, you could start a new chat session.</p>
<p>A new chat session could give you a clean context window in which you can express your purpose in a clearer way. And hopefully you would get a better reply from LLMs.</p>
<p>If you think the current conversation goes too long, you can start a new session as well. The basic idea is that the clearer the content in context window, the better response you could get. You can always start a new session, it&rsquo;s free!</p>
<h2 id="api-prompting-techniques">API Prompting Techniques<a hidden class="anchor" aria-hidden="true" href="#api-prompting-techniques">#</a></h2>
<p>If you are a software engineer and need to interact with LLMs through their APIs, there are something deeper compared to web interface you should understand.</p>
<h3 id="llms-dont-have-memory">LLMs Don&rsquo;t Have Memory<a hidden class="anchor" aria-hidden="true" href="#llms-dont-have-memory">#</a></h3>
<p>On web interface, we can have sessions with LLMs. In each session, all the back and forth interactions are recorded in a single webpage. But actually, LLMs don&rsquo;t have memory. They are stateless, like HTTP protocol. The way to make they remember is to include all previous interactions into your prompt. This is done automatically by web interface, and normally you need to do it by yourself while interacting by APIs.</p>
<p>Stateless LLMs is very flexible. Each time the response from LLM is solely based on what&rsquo;s inside its conext window (your prompt). Unlike web interface, you have a chance to manipulate the memories according to you requirements before issuing them to LLM. In multi-agent scenario, this is very useful.</p>
<h3 id="how-do-llms-manifest-randomness-creativity">How do LLMs Manifest Randomness (Creativity)<a hidden class="anchor" aria-hidden="true" href="#how-do-llms-manifest-randomness-creativity">#</a></h3>
<p>You must have been noticed that LLMs&rsquo; responses are not exactly same even though you prompt with exactly the same words. LLMs leverage <strong>Temperature (T), top P and top K</strong>, and a final random sampling mechanism to realize randomness, or we can say creativity.</p>
<p>This formular illustrates how parameter T is involved in the final softmax layer:</p>
<p>$$P_i = \cfrac{e^{z_i/T}}{\sum_{j=1}^{K}e^{z_j/T}}$$</p>
<p>The logits are divided by the value of T. So, if T&lt;1, large probability would become even larger and small probability would become even smaller. If T&gt;1, the differences of probabilities would be squeezed.</p>
<p>Top P and top K control the sampling range. Top P means the sum of all chosen top tokens&rsquo; probability should &gt;= P. Top K simply means the first K tokens.</p>
<p>Combine all these three parameters, we can see that parameter T is crucial. It changes the value of probability and consequently the sampling range. The final choice is within the selected token range. Suppose there are 3 tokens in the range. A 60%, B 30% and C 10% (top P = 1, top K &gt;= 3). The choice is simply to perform a multinomial sampling with only one outcome.</p>
<p>Last, one single token is generated with this kind of randomness. And the next token would be generated in the same way by &ldquo;considering&rdquo; all the previous tokens in the context window of LLM. Randomness is propagated along the way like this … This is the randomness/creativity mechanism of LLM.</p>
<p>When we set T=0 (it cannot be real zero), it&rsquo;s called Greedy Decoding which means we are only interested in the most probability token. While greedy decoding, the randomness is at the lowest level, but randomness is still existed due to tie scenarios.</p>
<h3 id="system-instruction">System Instruction<a hidden class="anchor" aria-hidden="true" href="#system-instruction">#</a></h3>
<p>System instruction is also prompt. However, it is different from user prompt. In each web session, there is only one system instrcution but may have many user prompts as long as there are multiple interactions with LLMs. System instruction serves as a overall goal to direct LLMs&rsquo; behavior. LLMs don&rsquo;t have memory. So, when using API interact with LLMs, software engineers need to manage memory by themselves. In this case, system instruction is always there as a parameter of API.</p>
<p>Where does system intruction come from? Why?</p>
<p>It is from traning, specificlly from fine-tuning phase. System instruction is a effective way to hedge prompt injection attack.</p>
<p>Basically, training a LLM consist of two steps. First step is called pre-training which training a LLM upon large corpora, such as the whole Internet. After this step, the model only know how to generate the next token and could not even know when to stop generating. Second step is call fine-tuning in which the training data is replaced by human generated question and answer pairs. Each piece of training data has roles, such as user, assistant and system. This is where system instruction come from and it&rsquo;s purpose is trained during fine-tuning step.</p>
<figure>
    <img loading="lazy" src="train_llm.png"
         alt="Two Steps to Train Llama-2-70B"/> <figcaption>
            <p>Two Steps to Train Llama-2-70B (Source: <a href="https://www.youtube.com/@AndrejKarpathy">https://www.youtube.com/@AndrejKarpathy</a>)</p>
        </figcaption>
</figure>

<p>For web interface users, system instruction is something you need to specify when you are trying to create a customized GPT.</p>
<h3 id="function-calling">Function Calling<a hidden class="anchor" aria-hidden="true" href="#function-calling">#</a></h3>
<p>Function calling is an API&rsquo;s parameter which takes a JSON structured data in which all available tools are described. Furthermore, when function calling parameter is presented, LLMs is guaranteed to response JSON formatted data in which which API and how should it be executed is described if they decide to take an action. This feature of LLMs make it easy for us to build LLM-based agent because JSON responses are guaranteed (you code still need to do basic check).</p>
<p>LLMs use Constrained Decoding to guarantee JSON response. Constrained decoding is a technique that guides the token generation process to ensure the output adheres to specific rules or formats (like JSON Schema). Instead of letting the LLMs generate tokens freely based solely on its learned probabilities, constrained decoding intervenes at each step of token generation to filter or bias the possible next tokens. A powerful technique that allows developers to precisely control the output of LLMs, making them more reliable and suitable for a wider range of real-world applications where structured and compliant outputs are critical. E.g. function calling of LLM output structured data in accordance with input JSON Schema.</p>
<h3 id="tree-of-thoughts-tot">Tree of Thoughts (ToT)<a hidden class="anchor" aria-hidden="true" href="#tree-of-thoughts-tot">#</a></h3>
<p>Chain of Thought (CoT) is to direct LLM to reason in one single path. Tree of Thoughts (ToT) is to iterate and collect all possible reasoning paths. Just like human, sometimes we need to think and analyze all different possibilities. ToT technique could make LLMs to do this kind of full and complete reasoning for us.</p>
<p>However, it&rsquo;s not easy to conduct ToT on web interface. ToT is more likely to develop by programming with APIs. Remember LLMs don&rsquo;t have memory. Whenever LLM give us a list of possibilities, we need to construct different reasoning paths by selecting one possibility out. In other words, we need to construct different reasoning memories to make LLMs continue the reasoning in different path.</p>
<figure>
    <img loading="lazy" src="ToT.png"
         alt="Tree of Thoughts Illustration"/> <figcaption>
            <p>Tree of Thoughts Illustration (Source: <a href="https://www.kaggle.com/whitepaper-prompt-engineering">https://www.kaggle.com/whitepaper-prompt-engineering</a>)</p>
        </figcaption>
</figure>

<p>Left is CoT, and right is ToT!</p>
<h3 id="self-consistency">Self-Consistency<a hidden class="anchor" aria-hidden="true" href="#self-consistency">#</a></h3>
<p>When you try to leverage LLMs to do NLP classification tasks, such as sentiment analysis, the result might not be always the same for the same input. This is because there might be multiple different reasoning paths available, and each LLM randomly pick one path out and give the result. To overall this issue, self-consistency technique could be employed.</p>
<p>The idea behind self-consistency is very simple. Try the same input multiple times, and take the majority as the final result. The majority is the most consistent answer and might be the most accurate one.</p>
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>Prompt engineering is a fundamental skill for effectively interacting with fine-tuned Large Language Models (LLMs) like ChatGPT and Gemini. Since LLMs &ldquo;know everything&rdquo; from their training data but lack context about individual users, prompt engineering helps us clearly communicate our objectives and control their responses. Essentially, it&rsquo;s &ldquo;programming&rdquo; LLMs using natural language such as English.</p>
<p>Techniques range from Persona, where you assign a role to the LLM, to providing Context for specific scenarios. N-Shot prompting (Zero-shot, One-shot, Few-shot) involves giving examples to guide the LLM&rsquo;s learning and output format. We can also explicitly request Output Formatting like JSON for structured data. More advanced techniques include Alternative Better Way for prompt refinement, Flip Interaction to have the LLM ask clarifying questions, and Chain of Thoughts (CoT) for step-by-step reasoning. ReAct (Reason and Act) is key for building LLM-based agents by providing tools and enabling iterative reasoning. Finally, In-Context Learning is crucial, allowing LLMs to process uploaded information or search results for relevant responses. Understanding these techniques empowers users to unlock the full potential of LLMs in various applications.</p>
<p>For developers interacting with LLMs via APIs, understanding concepts like statelessness (no memory), randomness (controlled by parameters like Temperature, Top P, and Top K), System Instructions (overall behavioral guidance during fine-tuning), and Function Calling (guaranteed structured output for tool use) is crucial. Advanced techniques like Tree of Thoughts (ToT) and Self-Consistency further enhance reasoning and reliability by exploring multiple reasoning paths or taking majority votes from multiple attempts.</p>
<p>Ultimately, effective prompt engineering allows users to harness the immense power of LLMs, transforming them from general-purpose models into highly effective, task-specific tools.</p>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<ul>
<li><a href="https://x.com/karpathy">https://x.com/karpathy</a></li>
<li><a href="https://www.kaggle.com/whitepaper-prompt-engineering">https://www.kaggle.com/whitepaper-prompt-engineering</a></li>
<li><a href="https://www.youtube.com/@AndrejKarpathy">https://www.youtube.com/@AndrejKarpathy</a></li>
<li><a href="https://ai.google.dev/gemini-api/docs">https://ai.google.dev/gemini-api/docs</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://xinlin-z.github.io/tags/prompt/">Prompt</a></li>
      <li><a href="https://xinlin-z.github.io/tags/llm/">LLM</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://xinlin-z.github.io/">Xinlin&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
