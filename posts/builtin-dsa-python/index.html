<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Built-in Data Structures and Algorithms in Python | Xinlin&#39;s Blog</title>
<meta name="keywords" content="Data Structure, Algorithm, Python">
<meta name="description" content="It&rsquo;s very important to choose the proper data structure and algorithm for various programming tasks. Even when we are using high-level programming language such as Python, it&rsquo;s still crucial in terms of time and space complexity. In this post, I&rsquo;ll try to summary all built-in data structures and algorithms in Python as a recap and reference. There are so many details which could be covered in this post, please refer to Python&rsquo;s official documents.">
<meta name="author" content="">
<link rel="canonical" href="https://xinlin-z.github.io/posts/builtin-dsa-python/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://xinlin-z.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://xinlin-z.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://xinlin-z.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://xinlin-z.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://xinlin-z.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://xinlin-z.github.io/posts/builtin-dsa-python/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
    onload="renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
        {left: '\\(', right: '\\)', display: false},
        {left: '\\[', right: '\\]', display: true}
      ],
      throwOnError : false
    });"></script>
<meta property="og:url" content="https://xinlin-z.github.io/posts/builtin-dsa-python/">
  <meta property="og:site_name" content="Xinlin&#39;s Blog">
  <meta property="og:title" content="Built-in Data Structures and Algorithms in Python">
  <meta property="og:description" content="It’s very important to choose the proper data structure and algorithm for various programming tasks. Even when we are using high-level programming language such as Python, it’s still crucial in terms of time and space complexity. In this post, I’ll try to summary all built-in data structures and algorithms in Python as a recap and reference. There are so many details which could be covered in this post, please refer to Python’s official documents.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-18T12:51:03+12:00">
    <meta property="article:modified_time" content="2025-07-18T12:51:03+12:00">
    <meta property="article:tag" content="Data Structure">
    <meta property="article:tag" content="Algorithm">
    <meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Built-in Data Structures and Algorithms in Python">
<meta name="twitter:description" content="It&rsquo;s very important to choose the proper data structure and algorithm for various programming tasks. Even when we are using high-level programming language such as Python, it&rsquo;s still crucial in terms of time and space complexity. In this post, I&rsquo;ll try to summary all built-in data structures and algorithms in Python as a recap and reference. There are so many details which could be covered in this post, please refer to Python&rsquo;s official documents.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://xinlin-z.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Built-in Data Structures and Algorithms in Python",
      "item": "https://xinlin-z.github.io/posts/builtin-dsa-python/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Built-in Data Structures and Algorithms in Python",
  "name": "Built-in Data Structures and Algorithms in Python",
  "description": "It\u0026rsquo;s very important to choose the proper data structure and algorithm for various programming tasks. Even when we are using high-level programming language such as Python, it\u0026rsquo;s still crucial in terms of time and space complexity. In this post, I\u0026rsquo;ll try to summary all built-in data structures and algorithms in Python as a recap and reference. There are so many details which could be covered in this post, please refer to Python\u0026rsquo;s official documents.\n",
  "keywords": [
    "Data Structure", "Algorithm", "Python"
  ],
  "articleBody": "It’s very important to choose the proper data structure and algorithm for various programming tasks. Even when we are using high-level programming language such as Python, it’s still crucial in terms of time and space complexity. In this post, I’ll try to summary all built-in data structures and algorithms in Python as a recap and reference. There are so many details which could be covered in this post, please refer to Python’s official documents.\nMost of the built-in data structures in Python are sequencial, which is also the most basic and important structure.\nThe first logo of Python, designed by Guido’s brother Just van Rossum\nlist List might be the most frequently used sequencial data structure in Python. It is fast, versatile and easy to use.\nmutable $O(1)$ for accessing random data element $O(1)$ for tail operation (append, pop) $O(n)$ for head and middle insert and delete $O(n)$ for membership testing (in operation) more space usage than tuple auto-resizing suitable to be used as Stack (LIFO) structure Normally, we use list to store homogeneous data, but this is not mandatory. It’s just a good programming style.\nOne common pitfall about list is to change it while iterating it:\n\u003e\u003e\u003e a = [1,2,3,4,5] \u003e\u003e\u003e for i in a: # quick fix, use a[:] instaed ... print(i) ... a.remove(i) ... 1 3 5 \u003e\u003e\u003e a [2, 4] Under list structure is just a piece of continuous memory so that it could achieve $O(1)$ for random element accessing. Due to the same reason, insert or delete at the head or in the middle needs to move memory and they become $O(n)$ operations.\ntuple and namedtuple Tuple is not just an immutable version of list. Tuple is best to for record data, such as rows retrieved from database. And these data are normally heterogeneous.\nimmutable $O(1)$ for accessing random data element $O(n)$ for membership testing less space usage than list faster than list for constant sequential data Namedtuple needs to be imported from collections module, and each element could be accessed as a property similar to column name of database table.\n\u003e\u003e\u003e from collections import namedtuple \u003e\u003e\u003e rec = namedtuple('datarow',('name','age','salary')) \u003e\u003e\u003e xinlin = rec('xinlin', 99, 100.123) \u003e\u003e\u003e xinlin.name, xinlin.age, xinlin.salary ('xinlin', 99, 100.123) bytearray We can treat bytearray as a special type of list which is designed only to hold raw byte data.\nlist-like, mutable, only hold raw byte data, 0 – 255 memory efficient design bytes tuple-like, immutable, only hold raw byte data, 0 – 255 memory efficient design array Array is less frequently used in Python due to the powerful and handy list. Compared to list, array is specially designed to store only homogeneous numeric data.\nlist-like, mutable store homogeneous numeric data, specify data type while initiating memory efficient design easy to interact with C API if store byte data, choose bytes or bytearray instead! \u003e\u003e\u003e import array \u003e\u003e\u003e ai = array.array('i',[1,2,3,4,5]) # i: int \u003e\u003e\u003e ad = array.array('d',[1,2,3,4,5]) # d: double-precision float \u003e\u003e\u003e ai array('i', [1, 2, 3, 4, 5]) \u003e\u003e\u003e ad array('d', [1.0, 2.0, 3.0, 4.0, 5.0]) Another reason why array is less often used is due to NumPy’s ndarray, which is so powerful and prevalent! The main benefits of array might be fact of built-in module.\nstr In Python, we don’t have char type, only str (string). Char could be represented by str object with length 1.\n$O(1)$ for accessing any single char $O(n)$ for membership testing rich and handy string operations deque When we need frequently insert or delete elements at the head of a sequential structure, deque might be the data structure we should employ. Deque (pronounced “deck”) is the Double-Ended Queue. It is specially designed and optimized for both end operations.\nmutable $O(1)$ for both end operations $O(n)$ for middle insert or delete $O(n)$ for membership testing $O(n)$ for randomly accessing by index support both auto-resizable and fixed-size thread-safe could be used as Stack (LIFO) and Queue (FIFO) structure Under deque structure is linked-list so that it could achieve $O(1)$ for both end operations. But don’t forget accessing random element in deque is a $O(n)$ operation due to the same reason.\nUnlike list, we could optionally initiate a deque object with a parameter called maxlen. With this parameter, the deque object would act like a rolling window.\n\u003e\u003e\u003e from collections import deque \u003e\u003e\u003e dq = deque(maxlen=3) \u003e\u003e\u003e dq.append(1) \u003e\u003e\u003e dq.append(2) \u003e\u003e\u003e dq.append(3) \u003e\u003e\u003e dq.append(4) \u003e\u003e\u003e dq deque([2, 3, 4], maxlen=3) \u003e\u003e\u003e dq.appendleft(1) \u003e\u003e\u003e dq deque([1, 2, 3], maxlen=3) If initiating deque object without maxlen, it just behaves like a standard double-ended auto-resizable queue.\nqueue In multi-threading programs, queue structure is quite common to share data between multiple threads. Python has a bulit-in queue module in which there are a few very common and powerful queue implementations could be used in multi-threading scenarios. They are SimpleQueue (FIFO), Queue (FIFO), LifoQueue and PriorityQueue (min-heap).\nmultiprocessing.Queue In multiprocessing module, there is a Queue class which is nearly a clone of queue.Queue but used in multiprocessing scenarios.\nset Set is a group of unordered unique hashable elements.\n$O(1)$ for adding or removing element $O(1)$ for membership testing! not support random element accessing support lots of standard mathematical set operations (such as intersection, union and difference) One common use case of set is to remove duplications:\n\u003e\u003e\u003e a = [1,2,3,2,1,2,3,4,5,4,3,2,1] \u003e\u003e\u003e a = list(set(a)) \u003e\u003e\u003e a [1, 2, 3, 4, 5] Hashable objects are those whose hash values would not be changed during their life time. Immutables are all hashable. Mutables are not. User-defined objects by default are hashable if __eq__ and __hash__ methods are not overrided.\nHashable is just the other side of unique immutable element.\nfrozenset Immutable version of set, hashable, could be an element in a set or as a key in dict object.\ndict Dict is a hash-mapping structure for unordered key-value pairs. It’s incredibly powerful and prevalent inside Python.\nmutable $O(1)$ for adding or removing KV pairs $O(1)$ for accessing by key (hashable) $O(1)$ for membership testing preserving inserting order (since 3.7, same as built-in OrderedDict from collections module) An example of the feature of preserving inserting order:\n\u003e\u003e\u003e ops = { ... 'step1': 'open the door of refrigerator', ... 'step2': 'push the elephant inside', ... 'step3': 'close the door', ... } \u003e\u003e\u003e for k,v in ops.items(): # iterating by inserting order ... print(k, ':', v) ... step1 : open the door of refrigerator step2 : push the elephant inside step3 : close the door Two caveats for leveraging the feature of preserving inserting order of dict object:\nupdating a key does not change its order deleting a key and re-inserting it moves it to the end Counter The Counter class, found in the collections module, is a specialized subclass of dict designed for quickly and efficiently counting hashable objects. We could say this is a built-in counting algorithm in Python.\n\u003e\u003e\u003e from collections import Counter \u003e\u003e\u003e a = 1,2,3,4,3,2,2,3,4,5,6,5,4,3,2 \u003e\u003e\u003e count = Counter(a) \u003e\u003e\u003e count Counter({2: 4, 3: 4, 4: 3, 5: 2, 1: 1, 6: 1}) \u003e\u003e\u003e count.most_common() [(2, 4), (3, 4), (4, 3), (5, 2), (1, 1), (6, 1)] \u003e\u003e\u003e count.most_common(3) [(2, 4), (3, 4), (4, 3)] sort (Timsort) The built-in sort algorithm in Python is very fast (C speed) and stable.\nStable means the order of multiple same objects would be preserved after sorting. It’s a critical feature in many scenarios.\nWe sometimes call the built-in sort algorithm in Python Timsort to honor the author Tim Peter. It’s a hybrid sorting algorithm combined from inserting sort and merge sort algorithms. Merge sort has a nice time complexity as $O(n\\log{n})$. Inserting sort is super fast if the sequence is partially sorted. The best time complexity of inserting sort is $O(n)$. The basic idea of Timsort is to take advantage of partially sorted sequences, called runs, merge runs instead of single element. The time complexity of Timsort is still $O(n\\log{n})$ but with a smaller hidden coefficient in most real cases.\nTwo ways to call Timsort algorithm, sorted and list.sort.\nbisect (Binary Search) As the name bisect implies, this is the famous efficient binary search algorithm. Python’s built-in in search operation has $O(n)$ time complexity on any sequential structure, $O(1)$ on hashing structure (set and dict). In between, bisect provides $O(\\log{n})$ time complexity search algorithm on sorted sequence.\nBasic useage of bisect module:\n\u003e\u003e\u003e from bisect import bisect_left, bisect \u003e\u003e\u003e a = [1,2,3,3,4,5,6,7,8] \u003e\u003e\u003e bisect(a, 3) # bisect right 4 \u003e\u003e\u003e bisect_left(a, 3) 2 \u003e\u003e\u003e bisect(a, 7) 8 \u003e\u003e\u003e bisect_left(a, 7) 7 Keep in mind:\nInterface bisect returns the index (i) where is just the right position of the one or more searching elements (e). If returns i, each element in a[i:] is larger than e. Interface bisect_left returns the index (i) where is just the left position of the one or more searching elements (e). If returns i, each element in a[:i] is smaller than e. Time complexity is $O(\\log{n})$ for both bisect and bisect_left. Only apply to sorted sequence. No error raised if applied to non-sorted sequence. Programmers need to make sure about it. A key parameter is provided, like sorted interface. Module bisect also offers us two insert methods:\n\u003e\u003e\u003e from bisect import insort_left, insort \u003e\u003e\u003e a = ['a','b','c1','c2','d'] \u003e\u003e\u003e insort(a, 'c0', key=lambda x:x[0]) # insort right \u003e\u003e\u003e a ['a', 'b', 'c1', 'c2', 'c0', 'd'] \u003e\u003e\u003e insort_left(a, 'c3', key=lambda x:x[0]) \u003e\u003e\u003e a ['a', 'b', 'c3', 'c1', 'c2', 'c0', 'd'] Pay attention:\nBoth insort and insort_left are $O(n)$ operations, just like insert something in the middle of a list. After inserting by insort or insort_left, the order keeps, even for those elements with same value. No element would be inserted in between of same-value-elements. Only apply to mutable and sorted sequences. heapq (Priority Queue) Python’s heapq module is an implementation of priority queue algorithm. It is stored in a list and min-heap implmentation, which means the top element ([0]) is the smallest one. It is the base for queue.PriorityQueue.\nheapq.heapify(x), $O(n)$ in-place linear operation, x must be a list, default comparison __lt__ is used. heapq.push(heap, newitem), $O(\\log{n})$ heapq.pop(heap), $O(\\log{n})$, if heap is empty, raise IndexError. If you only need to read the top element, no need to pop, read heap[0]. heapq.heappushpop(heap, newitem) is faster than heapq.push and heapq.pop. But the returned element might be the one just pushed. heapq.heapreplace(heap, newitem) is faster than heapq.pop and heapq.push. Pop first. So, it could not be applied on an empty heap. And the returned element is guaranteed from the original heap before push. Since the implementation of heap module is based on list, how could push and pop operation reach $O(\\log{n})$ time complexity?\nWhen push, it’s not inserting in the middle, the append method is used, and then pop up (sift up). When pop, the last element is swap to the position of index 0, and then heapify down (sift down).\ndataclass Python’s dataclass decorator gives us a convenient way create a class holding various data, like a struct in C. A bunch of boilerplate functions could be automatically added when decorated, such as the default three: __init__, __repr__ and __eq___.\nfrom dataclasses import dataclass # order=True gives you __lt__, __le__, __gt__ and __ge__. # frozen=True gives you read-only instance, no assigning operation. @dataclass(order=True, frozen=True) class Point: x: int # This is called a field. y: int = 0 p1 = Point(1, 2) p2 = Point(1, 2) p3 = Point(3) print(p1) # Point(x=1, y=2) print(p1 == p2) # True print(p1 == p3) # False print(p1.x) # 1 print(p1 \u003e p3) # False # p2.x = 5, raise When the fields are mutable objects such as list and dict, it’s a little tricky to define:\nfrom dataclasses import field @dataclass class xyz: # items: list[int] = [] # DO NOT DO THIS !!! items: list[int] = field(default_factory=list) settings: dict[str,str] = field(default_factory=dict) functools functools.lru_cache Python’s functools.lru_cache is a decorator that provides a Least Recently Used (LRU) cache for function calls. It’s used for memoization, which means it stores the results of expensive function calls and returns the cached result when the same inputs occur again, avoiding redundant computations. When the memory is used up, the least recently used item would be removed to new memory item. It is suitable for those functions do lots of computation.\nitertools A few handy iteration algorithms in itertools module.\nitertools.chain Iterating more than one iterables in a chain way:\n\u003e\u003e\u003e import itertools \u003e\u003e\u003e \u003e\u003e\u003e a = 1,2 \u003e\u003e\u003e b = [3] \u003e\u003e\u003e c = (i for i in range(4,6)) \u003e\u003e\u003e for i in itertools.chain(a,b,c): ... print(i) ... 1 2 3 4 5 itertools.combinations Generate all combinations by specifying items and combination length:\n\u003e\u003e\u003e for c in itertools.combinations('abcd',3): ... print(c) ... ('a', 'b', 'c') ('a', 'b', 'd') ('a', 'c', 'd') ('b', 'c', 'd') itertools.permutations Generate all permutations by specifying items and permutation length:\n\u003e\u003e\u003e for p in itertools.permutations('abc',2): ... print(p) ... ('a', 'b') ('a', 'c') ('b', 'a') ('b', 'c') ('c', 'a') ('c', 'b') Solve Combination and Permutation by Backtracking Algorithm\nitertools.product Generate Cartesian Product:\n\u003e\u003e\u003e for p in itertools.product('ab','12'): ... print(p) ... ('a', '1') ('a', '2') ('b', '1') ('b', '2') itertools.groupby Generate groups based on user-defined criterior (don’t be confused with group by clause in SQL):\n\u003e\u003e\u003e a = 'a','ab','b','abc','c','bcd','acd' \u003e\u003e\u003e \u003e\u003e\u003e # groupby length \u003e\u003e\u003e result = {} \u003e\u003e\u003e for k,g in itertools.groupby(a,len): ... result.setdefault(k,[]).append(tuple(g)) ... \u003e\u003e\u003e result {1: [('a',), ('b',), ('c',)], 2: [('ab',)], 3: [('abc',), ('bcd', 'acd')]} \u003e\u003e\u003e \u003e\u003e\u003e # groupby first letter \u003e\u003e\u003e result = {} \u003e\u003e\u003e for k,g in itertools.groupby(a,lambda x:x[0]): ... result.setdefault(k,[]).append(tuple(g)) ... \u003e\u003e\u003e result {'a': [('a', 'ab'), ('abc',), ('acd',)], 'b': [('b',), ('bcd',)], 'c': [('c',)]} Speedup Tricks Comprehension is Faster Than Loops Comprehension could be used to construct list, set or dict. They are called list comprehension, set comprehension and dict comprehension respectively. This concise syntax provides CPython interpreter a chance to implement them in C level. The overhead of repeatedly calling append or add methods for each element is removed, and CPython could pre-allocate enough memory to the whole returned object.\n$ python -m timeit -p 'a = [i for i in range(10000)]' 1000 loops, best of 5: 346 usec per loop $ python -m timeit -p -s 'a=[]' 'for i in range(10000): a.append(i)' 100 loops, best of 5: 733 usec per loop $ python -m timeit -p 'a = {i:i for i in range(10000)}' 500 loops, best of 5: 654 usec per loop $ python -m timeit -p -s 'a={}' 'for i in range(10000): a[i]=i' 500 loops, best of 5: 777 usec per loop Avoid Function Calling while Initializing Common Objects Unless you have to:\n$ python -m timeit -p 'a=[]' 10000000 loops, best of 5: 28.7 nsec per loop $ python -m timeit -p 'a=list()' 5000000 loops, best of 5: 83.3 nsec per loop $ python -m timeit -p 'a=()' 20000000 loops, best of 5: 15 nsec per loop $ python -m timeit -p 'a=tuple()' 5000000 loops, best of 5: 45 nsec per loop $ python -m timeit -p 'a={}' 10000000 loops, best of 5: 29.4 nsec per loop $ python -m timeit -p 'a=dict()' 5000000 loops, best of 5: 77.4 nsec per loop Using Tuple as Constant Data Structure Initializing a tuple is cheaper than an equal list:\n$ python -m timeit -p 'a = 1,2,3,4' 20000000 loops, best of 5: 14.8 nsec per loop $ python -m timeit -p 'a = [1,2,3,4]' 5000000 loops, best of 5: 54.9 nsec per loop OK… Happy coding with Python!\n",
  "wordCount" : "2553",
  "inLanguage": "en",
  "datePublished": "2025-07-18T12:51:03+12:00",
  "dateModified": "2025-07-18T12:51:03+12:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://xinlin-z.github.io/posts/builtin-dsa-python/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Xinlin's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://xinlin-z.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xinlin-z.github.io/" accesskey="h" title="Xinlin&#39;s Blog (Alt + H)">Xinlin&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://xinlin-z.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://xinlin-z.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://xinlin-z.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://xinlin-z.github.io/pages/about" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Built-in Data Structures and Algorithms in Python
    </h1>
    <div class="post-meta"><span title='2025-07-18 12:51:03 +1200 NZST'>July 18, 2025</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#list" aria-label="list">list</a></li>
                <li>
                    <a href="#tuple-and-namedtuple" aria-label="tuple and namedtuple">tuple and namedtuple</a></li>
                <li>
                    <a href="#bytearray" aria-label="bytearray">bytearray</a></li>
                <li>
                    <a href="#bytes" aria-label="bytes">bytes</a></li>
                <li>
                    <a href="#array" aria-label="array">array</a></li>
                <li>
                    <a href="#str" aria-label="str">str</a></li>
                <li>
                    <a href="#deque" aria-label="deque">deque</a></li>
                <li>
                    <a href="#queue" aria-label="queue">queue</a></li>
                <li>
                    <a href="#multiprocessingqueue" aria-label="multiprocessing.Queue">multiprocessing.Queue</a></li>
                <li>
                    <a href="#set" aria-label="set">set</a></li>
                <li>
                    <a href="#frozenset" aria-label="frozenset">frozenset</a></li>
                <li>
                    <a href="#dict" aria-label="dict">dict</a></li>
                <li>
                    <a href="#counter" aria-label="Counter">Counter</a></li>
                <li>
                    <a href="#sort-timsort" aria-label="sort (Timsort)">sort (Timsort)</a></li>
                <li>
                    <a href="#bisect-binary-search" aria-label="bisect (Binary Search)">bisect (Binary Search)</a></li>
                <li>
                    <a href="#heapq-priority-queue" aria-label="heapq (Priority Queue)">heapq (Priority Queue)</a></li>
                <li>
                    <a href="#dataclass" aria-label="dataclass">dataclass</a></li>
                <li>
                    <a href="#functools" aria-label="functools">functools</a></li>
                <li>
                    <a href="#itertools" aria-label="itertools">itertools</a></li>
                <li>
                    <a href="#speedup-tricks" aria-label="Speedup Tricks">Speedup Tricks</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>It&rsquo;s very important to choose the proper data structure and algorithm for various programming tasks. Even when we are using high-level programming language such as Python, it&rsquo;s still crucial in terms of time and space complexity. In this post, I&rsquo;ll try to summary all built-in data structures and algorithms in Python as a recap and reference. There are so many details which could be covered in this post, please refer to Python&rsquo;s official documents.</p>
<blockquote>
<p>Most of the built-in data structures in Python are sequencial, which is also the most basic and important structure.</p></blockquote>
<figure>
    <img loading="lazy" src="python_logo.jpg"
         alt="The first logo of Python, designed by Guido&#39;s brother Just van Rossum"/> <figcaption>
            <p>The first logo of Python, designed by Guido&rsquo;s brother Just van Rossum</p>
        </figcaption>
</figure>

<h2 id="list">list<a hidden class="anchor" aria-hidden="true" href="#list">#</a></h2>
<p>List might be the most frequently used sequencial data structure in Python. It is fast, versatile and easy to use.</p>
<ul>
<li>mutable</li>
<li>$O(1)$ for accessing random data element</li>
<li>$O(1)$ for tail operation (append, pop)</li>
<li>$O(n)$ for head and middle insert and delete</li>
<li>$O(n)$ for membership testing (in operation)</li>
<li>more space usage than tuple</li>
<li>auto-resizing</li>
<li>suitable to be used as <strong>Stack</strong> (LIFO) structure</li>
</ul>
<p>Normally, we use list to store homogeneous data, but this is not mandatory. It&rsquo;s just a good programming style.</p>
<p>One common pitfall about list is to change it while iterating it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> a <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>]
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> a:  <span style="color:#75715e"># quick fix, use a[:] instaed</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>   print(i)
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>   a<span style="color:#f92672">.</span>remove(i)
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span> 
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> a
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>]
</span></span></code></pre></div><p>Under list structure is just a piece of continuous memory so that it could achieve $O(1)$ for random element accessing. Due to the same reason, insert or delete at the head or in the middle needs to move memory and they become $O(n)$ operations.</p>
<h2 id="tuple-and-namedtuple">tuple and namedtuple<a hidden class="anchor" aria-hidden="true" href="#tuple-and-namedtuple">#</a></h2>
<p>Tuple is not just an immutable version of list. Tuple is best to for record data, such as rows retrieved from database. And these data are normally heterogeneous.</p>
<ul>
<li>immutable</li>
<li>$O(1)$ for accessing random data element</li>
<li>$O(n)$ for membership testing</li>
<li>less space usage than list</li>
<li>faster than list for constant sequential data</li>
</ul>
<p>Namedtuple needs to be imported from collections module, and each element could be accessed as a property similar to column name of database table.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> namedtuple
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> rec <span style="color:#f92672">=</span> namedtuple(<span style="color:#e6db74">&#39;datarow&#39;</span>,(<span style="color:#e6db74">&#39;name&#39;</span>,<span style="color:#e6db74">&#39;age&#39;</span>,<span style="color:#e6db74">&#39;salary&#39;</span>))
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> xinlin <span style="color:#f92672">=</span> rec(<span style="color:#e6db74">&#39;xinlin&#39;</span>, <span style="color:#ae81ff">99</span>, <span style="color:#ae81ff">100.123</span>)     
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> xinlin<span style="color:#f92672">.</span>name, xinlin<span style="color:#f92672">.</span>age, xinlin<span style="color:#f92672">.</span>salary
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;xinlin&#39;</span>, <span style="color:#ae81ff">99</span>, <span style="color:#ae81ff">100.123</span>)
</span></span></code></pre></div><h2 id="bytearray">bytearray<a hidden class="anchor" aria-hidden="true" href="#bytearray">#</a></h2>
<p>We can treat bytearray as a special type of list which is designed only to hold raw byte data.</p>
<ul>
<li>list-like, mutable, only hold raw byte data, 0 &ndash; 255</li>
<li>memory efficient design</li>
</ul>
<h2 id="bytes">bytes<a hidden class="anchor" aria-hidden="true" href="#bytes">#</a></h2>
<ul>
<li>tuple-like, immutable, only hold raw byte data, 0 &ndash; 255</li>
<li>memory efficient design</li>
</ul>
<h2 id="array">array<a hidden class="anchor" aria-hidden="true" href="#array">#</a></h2>
<p>Array is less frequently used in Python due to the powerful and handy list. Compared to list, array is specially designed to store only homogeneous numeric data.</p>
<ul>
<li>list-like, mutable</li>
<li>store homogeneous numeric data, specify data type while initiating</li>
<li>memory efficient design</li>
<li>easy to interact with C API</li>
<li>if store byte data, choose bytes or bytearray instead!</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">import</span> array
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> ai <span style="color:#f92672">=</span> array<span style="color:#f92672">.</span>array(<span style="color:#e6db74">&#39;i&#39;</span>,[<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>])  <span style="color:#75715e"># i: int</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> ad <span style="color:#f92672">=</span> array<span style="color:#f92672">.</span>array(<span style="color:#e6db74">&#39;d&#39;</span>,[<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>])  <span style="color:#75715e"># d: double-precision float</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> ai
</span></span><span style="display:flex;"><span>array(<span style="color:#e6db74">&#39;i&#39;</span>, [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>])
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> ad
</span></span><span style="display:flex;"><span>array(<span style="color:#e6db74">&#39;d&#39;</span>, [<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">2.0</span>, <span style="color:#ae81ff">3.0</span>, <span style="color:#ae81ff">4.0</span>, <span style="color:#ae81ff">5.0</span>])
</span></span></code></pre></div><p>Another reason why array is less often used is due to NumPy&rsquo;s ndarray, which is so powerful and prevalent! The main benefits of array might be fact of built-in module.</p>
<h2 id="str">str<a hidden class="anchor" aria-hidden="true" href="#str">#</a></h2>
<p>In Python, we don&rsquo;t have char type, only str (string). Char could be represented by str object with length 1.</p>
<ul>
<li>$O(1)$ for accessing any single char</li>
<li>$O(n)$ for membership testing</li>
<li>rich and handy string operations</li>
</ul>
<h2 id="deque">deque<a hidden class="anchor" aria-hidden="true" href="#deque">#</a></h2>
<p>When we need frequently insert or delete elements at the head of a sequential structure, deque might be the data structure we should employ. Deque (pronounced &ldquo;deck&rdquo;) is the Double-Ended Queue. It is specially designed and optimized for both end operations.</p>
<ul>
<li>mutable</li>
<li>$O(1)$ for both end operations</li>
<li>$O(n)$ for middle insert or delete</li>
<li>$O(n)$ for membership testing</li>
<li>$O(n)$ for randomly accessing by index</li>
<li>support both auto-resizable and fixed-size</li>
<li>thread-safe</li>
<li>could be used as <strong>Stack</strong> (LIFO) and <strong>Queue</strong> (FIFO) structure</li>
</ul>
<p>Under deque structure is linked-list so that it could achieve $O(1)$ for both end operations. But don&rsquo;t forget accessing random element in deque is a $O(n)$ operation due to the same reason.</p>
<p>Unlike list, we could optionally initiate a deque object with a parameter called maxlen. With this parameter, the deque object would act like a rolling window.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> dq <span style="color:#f92672">=</span> deque(maxlen<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> dq<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> dq<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> dq<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> dq<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> dq
</span></span><span style="display:flex;"><span>deque([<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>], maxlen<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> dq<span style="color:#f92672">.</span>appendleft(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> dq
</span></span><span style="display:flex;"><span>deque([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], maxlen<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
</span></span></code></pre></div><p>If initiating deque object without maxlen, it just behaves like a standard double-ended auto-resizable queue.</p>
<h2 id="queue">queue<a hidden class="anchor" aria-hidden="true" href="#queue">#</a></h2>
<p>In multi-threading programs, queue structure is quite common to share data between multiple threads. Python has a bulit-in queue module in which there are a few very common and powerful queue implementations could be used in multi-threading scenarios. They are <code>SimpleQueue</code> (FIFO), <code>Queue</code> (FIFO), <code>LifoQueue</code> and <code>PriorityQueue</code> (min-heap).</p>
<h2 id="multiprocessingqueue">multiprocessing.Queue<a hidden class="anchor" aria-hidden="true" href="#multiprocessingqueue">#</a></h2>
<p>In multiprocessing module, there is a Queue class which is nearly a clone of queue.Queue but used in multiprocessing scenarios.</p>
<h2 id="set">set<a hidden class="anchor" aria-hidden="true" href="#set">#</a></h2>
<p>Set is a group of unordered unique hashable elements.</p>
<ul>
<li>$O(1)$ for adding or removing element</li>
<li>$O(1)$ for membership testing!</li>
<li>not support random element accessing</li>
<li>support lots of standard mathematical set operations (such as intersection, union and difference)</li>
</ul>
<p>One common use case of set is to remove duplications:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> a <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> a <span style="color:#f92672">=</span> list(set(a))
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> a
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>]
</span></span></code></pre></div><blockquote>
<p><strong>Hashable</strong> objects are those whose hash values would not be changed during their life time. Immutables are all hashable. Mutables are not. User-defined objects by default are hashable if __eq__ and __hash__ methods are not overrided.</p></blockquote>
<p>Hashable is just the other side of unique immutable element.</p>
<h2 id="frozenset">frozenset<a hidden class="anchor" aria-hidden="true" href="#frozenset">#</a></h2>
<p>Immutable version of set, hashable, could be an element in a set or as a key in dict object.</p>
<h2 id="dict">dict<a hidden class="anchor" aria-hidden="true" href="#dict">#</a></h2>
<p>Dict is a hash-mapping structure for unordered key-value pairs. It&rsquo;s incredibly powerful and prevalent inside Python.</p>
<ul>
<li>mutable</li>
<li>$O(1)$ for adding or removing KV pairs</li>
<li>$O(1)$ for accessing by key (hashable)</li>
<li>$O(1)$ for membership testing</li>
<li>preserving inserting order (since 3.7, same as built-in OrderedDict from collections module)</li>
</ul>
<p>An example of the feature of preserving inserting order:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> ops <span style="color:#f92672">=</span> { 
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     <span style="color:#e6db74">&#39;step1&#39;</span>: <span style="color:#e6db74">&#39;open the door of refrigerator&#39;</span>,
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     <span style="color:#e6db74">&#39;step2&#39;</span>: <span style="color:#e6db74">&#39;push the elephant inside&#39;</span>,
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     <span style="color:#e6db74">&#39;step3&#39;</span>: <span style="color:#e6db74">&#39;close the door&#39;</span>,
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span> }
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">for</span> k,v <span style="color:#f92672">in</span> ops<span style="color:#f92672">.</span>items():  <span style="color:#75715e"># iterating by inserting order</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     print(k, <span style="color:#e6db74">&#39;:&#39;</span>, v)
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span> 
</span></span><span style="display:flex;"><span>step1 : open the door of refrigerator
</span></span><span style="display:flex;"><span>step2 : push the elephant inside
</span></span><span style="display:flex;"><span>step3 : close the door
</span></span></code></pre></div><p>Two caveats for leveraging the feature of preserving inserting order of dict object:</p>
<ol>
<li>updating a key does not change its order</li>
<li>deleting a key and re-inserting it moves it to the end</li>
</ol>
<h2 id="counter">Counter<a hidden class="anchor" aria-hidden="true" href="#counter">#</a></h2>
<p>The Counter class, found in the collections module, is a specialized subclass of dict designed for quickly and efficiently counting hashable objects. We could say this is a built-in counting algorithm in Python.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> Counter
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> count <span style="color:#f92672">=</span> Counter(a)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> count
</span></span><span style="display:flex;"><span>Counter({<span style="color:#ae81ff">2</span>: <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>: <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>: <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>: <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>: <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">6</span>: <span style="color:#ae81ff">1</span>})
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> count<span style="color:#f92672">.</span>most_common()
</span></span><span style="display:flex;"><span>[(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>), (<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>), (<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">1</span>)]
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> count<span style="color:#f92672">.</span>most_common(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>[(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>)]
</span></span></code></pre></div><h2 id="sort-timsort">sort (Timsort)<a hidden class="anchor" aria-hidden="true" href="#sort-timsort">#</a></h2>
<p>The built-in sort algorithm in Python is very fast (C speed) and <strong>stable</strong>.</p>
<blockquote>
<p>Stable means the order of multiple same objects would be preserved after sorting. It&rsquo;s a critical feature in many scenarios.</p></blockquote>
<p>We sometimes call the built-in sort algorithm in Python Timsort to honor the author Tim Peter. It&rsquo;s a hybrid sorting algorithm combined from inserting sort and merge sort algorithms. Merge sort has a nice time complexity as $O(n\log{n})$. Inserting sort is super fast if the sequence is partially sorted. The best time complexity of inserting sort is $O(n)$. The basic idea of Timsort is to take advantage of partially sorted sequences, called runs, merge runs instead of single element. The time complexity of Timsort is still $O(n\log{n})$ but with a smaller hidden coefficient in most real cases.</p>
<p>Two ways to call Timsort algorithm, <code>sorted</code> and <code>list.sort</code>.</p>
<h2 id="bisect-binary-search">bisect (Binary Search)<a hidden class="anchor" aria-hidden="true" href="#bisect-binary-search">#</a></h2>
<p>As the name bisect implies, this is the famous efficient binary search algorithm. Python&rsquo;s built-in <code>in</code> search operation has $O(n)$ time complexity on any sequential structure, $O(1)$ on hashing structure (set and dict). In between, bisect provides $O(\log{n})$ time complexity search algorithm on sorted sequence.</p>
<p>Basic useage of bisect module:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">from</span> bisect <span style="color:#f92672">import</span> bisect_left, bisect
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> a <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">8</span>]  
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> bisect(a, <span style="color:#ae81ff">3</span>)  <span style="color:#75715e"># bisect right</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> bisect_left(a, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> bisect(a, <span style="color:#ae81ff">7</span>)     
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> bisect_left(a, <span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>
</span></span></code></pre></div><p>Keep in mind:</p>
<ul>
<li>Interface bisect returns the index (i) where is just the right position of the one or more searching elements (e). If returns i, each element in a[i:] is larger than e.</li>
<li>Interface bisect_left returns the index (i) where is just the left position of the one or more searching elements (e). If returns i, each element in a[:i] is smaller than e.</li>
<li>Time complexity is $O(\log{n})$ for both bisect and bisect_left.</li>
<li>Only apply to sorted sequence. No error raised if applied to non-sorted sequence. Programmers need to make sure about it.</li>
<li>A key parameter is provided, like sorted interface.</li>
</ul>
<p>Module bisect also offers us two insert methods:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">from</span> bisect <span style="color:#f92672">import</span> insort_left, insort
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> a <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;a&#39;</span>,<span style="color:#e6db74">&#39;b&#39;</span>,<span style="color:#e6db74">&#39;c1&#39;</span>,<span style="color:#e6db74">&#39;c2&#39;</span>,<span style="color:#e6db74">&#39;d&#39;</span>]
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> insort(a, <span style="color:#e6db74">&#39;c0&#39;</span>, key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> x:x[<span style="color:#ae81ff">0</span>])  <span style="color:#75715e"># insort right</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> a
</span></span><span style="display:flex;"><span>[<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c1&#39;</span>, <span style="color:#e6db74">&#39;c2&#39;</span>, <span style="color:#e6db74">&#39;c0&#39;</span>, <span style="color:#e6db74">&#39;d&#39;</span>]
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> insort_left(a, <span style="color:#e6db74">&#39;c3&#39;</span>, key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> x:x[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> a
</span></span><span style="display:flex;"><span>[<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c3&#39;</span>, <span style="color:#e6db74">&#39;c1&#39;</span>, <span style="color:#e6db74">&#39;c2&#39;</span>, <span style="color:#e6db74">&#39;c0&#39;</span>, <span style="color:#e6db74">&#39;d&#39;</span>]
</span></span></code></pre></div><p>Pay attention:</p>
<ul>
<li>Both insort and insort_left are $O(n)$ operations, just like insert something in the middle of a list.</li>
<li>After inserting by insort or insort_left, the order keeps, even for those elements with same value. No element would be inserted in between of same-value-elements.</li>
<li>Only apply to mutable and sorted sequences.</li>
</ul>
<h2 id="heapq-priority-queue">heapq (Priority Queue)<a hidden class="anchor" aria-hidden="true" href="#heapq-priority-queue">#</a></h2>
<p>Python&rsquo;s heapq module is an implementation of priority queue algorithm. It is stored in a list and min-heap implmentation, which means the top element (<code>[0]</code>) is the smallest one. It is the base for <code>queue.PriorityQueue</code>.</p>
<ul>
<li><code>heapq.heapify(x)</code>, $O(n)$ in-place linear operation, x must be a list, default comparison <code>__lt__</code> is used.</li>
<li><code>heapq.push(heap, newitem)</code>, $O(\log{n})$</li>
<li><code>heapq.pop(heap)</code>, $O(\log{n})$, if heap is empty, raise IndexError. If you only need to read the top element, no need to pop, read heap[0].</li>
<li><code>heapq.heappushpop(heap, newitem)</code> is faster than heapq.push and heapq.pop. But the returned element might be the one just pushed.</li>
<li><code>heapq.heapreplace(heap, newitem)</code> is faster than heapq.pop and heapq.push. Pop first. So, it could not be applied on an empty heap. And the returned element is guaranteed from the original heap before push.</li>
</ul>
<p>Since the implementation of heap module is based on list, how could push and pop operation reach $O(\log{n})$ time complexity?</p>
<p>When push, it&rsquo;s not inserting in the middle, the append method is used, and then pop up (sift up). When pop, the last element is swap to the position of index 0, and then heapify down (sift down).</p>
<h2 id="dataclass">dataclass<a hidden class="anchor" aria-hidden="true" href="#dataclass">#</a></h2>
<p>Python&rsquo;s dataclass decorator gives us a convenient way create a class holding various data, like a struct in C. A bunch of boilerplate functions could be automatically added when decorated, such as the default three: <code>__init__</code>, <code>__repr__</code> and <code>__eq___</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> dataclasses <span style="color:#f92672">import</span> dataclass
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># order=True gives you __lt__, __le__, __gt__ and __ge__.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># frozen=True gives you read-only instance, no assigning operation.</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@dataclass</span>(order<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, frozen<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>:
</span></span><span style="display:flex;"><span>    x: int  <span style="color:#75715e"># This is called a field.</span>
</span></span><span style="display:flex;"><span>    y: int <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p1 <span style="color:#f92672">=</span> Point(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>p2 <span style="color:#f92672">=</span> Point(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>p3 <span style="color:#f92672">=</span> Point(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(p1)         <span style="color:#75715e"># Point(x=1, y=2)</span>
</span></span><span style="display:flex;"><span>print(p1 <span style="color:#f92672">==</span> p2)   <span style="color:#75715e"># True</span>
</span></span><span style="display:flex;"><span>print(p1 <span style="color:#f92672">==</span> p3)   <span style="color:#75715e"># False</span>
</span></span><span style="display:flex;"><span>print(p1<span style="color:#f92672">.</span>x)       <span style="color:#75715e"># 1</span>
</span></span><span style="display:flex;"><span>print(p1 <span style="color:#f92672">&gt;</span> p3)    <span style="color:#75715e"># False</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># p2.x = 5, raise</span>
</span></span></code></pre></div><p>When the fields are mutable objects such as list and dict, it&rsquo;s a little tricky to define:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> dataclasses <span style="color:#f92672">import</span> field
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@dataclass</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">xyz</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># items: list[int] = []  # DO NOT DO THIS !!!</span>
</span></span><span style="display:flex;"><span>    items: list[int] <span style="color:#f92672">=</span> field(default_factory<span style="color:#f92672">=</span>list)
</span></span><span style="display:flex;"><span>    settings: dict[str,str] <span style="color:#f92672">=</span> field(default_factory<span style="color:#f92672">=</span>dict)
</span></span></code></pre></div><h2 id="functools">functools<a hidden class="anchor" aria-hidden="true" href="#functools">#</a></h2>
<ul>
<li><strong>functools.lru_cache</strong></li>
</ul>
<p>Python&rsquo;s functools.lru_cache is a decorator that provides a <strong>Least Recently Used (LRU)</strong> cache for function calls. It&rsquo;s used for memoization, which means it stores the results of expensive function calls and returns the cached result when the same inputs occur again, avoiding redundant computations. When the memory is used up, the least recently used item would be removed to new memory item. It is suitable for those functions do lots of computation.</p>
<h2 id="itertools">itertools<a hidden class="anchor" aria-hidden="true" href="#itertools">#</a></h2>
<p>A few handy iteration algorithms in itertools module.</p>
<ul>
<li><strong>itertools.chain</strong></li>
</ul>
<p>Iterating more than one iterables in a chain way:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">import</span> itertools
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> b <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> c <span style="color:#f92672">=</span> (i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> itertools<span style="color:#f92672">.</span>chain(a,b,c):
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>   print(i)
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span></code></pre></div><ul>
<li><strong>itertools.combinations</strong></li>
</ul>
<p>Generate all combinations by specifying items and combination length:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> itertools<span style="color:#f92672">.</span>combinations(<span style="color:#e6db74">&#39;abcd&#39;</span>,<span style="color:#ae81ff">3</span>):
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>   print(c)
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;d&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;d&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;d&#39;</span>)
</span></span></code></pre></div><ul>
<li><strong>itertools.permutations</strong></li>
</ul>
<p>Generate all permutations by specifying items and permutation length:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> itertools<span style="color:#f92672">.</span>permutations(<span style="color:#e6db74">&#39;abc&#39;</span>,<span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>   print(p)
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;a&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;a&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>)
</span></span></code></pre></div><blockquote>
<p><a href="https://xinlin-z.github.io/posts/backtracking/">Solve Combination and Permutation by Backtracking Algorithm</a></p></blockquote>
<ul>
<li><strong>itertools.product</strong></li>
</ul>
<p>Generate Cartesian Product:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> itertools<span style="color:#f92672">.</span>product(<span style="color:#e6db74">&#39;ab&#39;</span>,<span style="color:#e6db74">&#39;12&#39;</span>):
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>   print(p)
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;1&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;2&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;1&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;2&#39;</span>)
</span></span></code></pre></div><ul>
<li><strong>itertools.groupby</strong></li>
</ul>
<p>Generate groups based on user-defined criterior (don&rsquo;t be confused with group by clause in SQL):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> a <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>,<span style="color:#e6db74">&#39;ab&#39;</span>,<span style="color:#e6db74">&#39;b&#39;</span>,<span style="color:#e6db74">&#39;abc&#39;</span>,<span style="color:#e6db74">&#39;c&#39;</span>,<span style="color:#e6db74">&#39;bcd&#39;</span>,<span style="color:#e6db74">&#39;acd&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#75715e"># groupby length</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> result <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">for</span> k,g <span style="color:#f92672">in</span> itertools<span style="color:#f92672">.</span>groupby(a,len):
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     result<span style="color:#f92672">.</span>setdefault(k,[])<span style="color:#f92672">.</span>append(tuple(g))
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> result
</span></span><span style="display:flex;"><span>{<span style="color:#ae81ff">1</span>: [(<span style="color:#e6db74">&#39;a&#39;</span>,), (<span style="color:#e6db74">&#39;b&#39;</span>,), (<span style="color:#e6db74">&#39;c&#39;</span>,)], <span style="color:#ae81ff">2</span>: [(<span style="color:#e6db74">&#39;ab&#39;</span>,)], <span style="color:#ae81ff">3</span>: [(<span style="color:#e6db74">&#39;abc&#39;</span>,), (<span style="color:#e6db74">&#39;bcd&#39;</span>, <span style="color:#e6db74">&#39;acd&#39;</span>)]}
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#75715e"># groupby first letter</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> result <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">for</span> k,g <span style="color:#f92672">in</span> itertools<span style="color:#f92672">.</span>groupby(a,<span style="color:#66d9ef">lambda</span> x:x[<span style="color:#ae81ff">0</span>]):
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     result<span style="color:#f92672">.</span>setdefault(k,[])<span style="color:#f92672">.</span>append(tuple(g))
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> result
</span></span><span style="display:flex;"><span>{<span style="color:#e6db74">&#39;a&#39;</span>: [(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;ab&#39;</span>), (<span style="color:#e6db74">&#39;abc&#39;</span>,), (<span style="color:#e6db74">&#39;acd&#39;</span>,)], <span style="color:#e6db74">&#39;b&#39;</span>: [(<span style="color:#e6db74">&#39;b&#39;</span>,), (<span style="color:#e6db74">&#39;bcd&#39;</span>,)], <span style="color:#e6db74">&#39;c&#39;</span>: [(<span style="color:#e6db74">&#39;c&#39;</span>,)]}
</span></span></code></pre></div><h2 id="speedup-tricks">Speedup Tricks<a hidden class="anchor" aria-hidden="true" href="#speedup-tricks">#</a></h2>
<ul>
<li><strong>Comprehension is Faster Than Loops</strong></li>
</ul>
<p>Comprehension could be used to construct list, set or dict. They are called list comprehension, set comprehension and dict comprehension respectively. This concise syntax provides CPython interpreter a chance to implement them in C level. The overhead of repeatedly calling append or add methods for each element is removed, and CPython could pre-allocate enough memory to the whole returned object.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ python -m timeit -p <span style="color:#e6db74">&#39;a = [i for i in range(10000)]&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1000</span> loops, best of 5: <span style="color:#ae81ff">346</span> usec per loop
</span></span><span style="display:flex;"><span>$ python -m timeit -p -s <span style="color:#e6db74">&#39;a=[]&#39;</span> <span style="color:#e6db74">&#39;for i in range(10000):  a.append(i)&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">100</span> loops, best of 5: <span style="color:#ae81ff">733</span> usec per loop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ python -m timeit -p <span style="color:#e6db74">&#39;a = {i:i for i in range(10000)}&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">500</span> loops, best of 5: <span style="color:#ae81ff">654</span> usec per loop
</span></span><span style="display:flex;"><span>$ python -m timeit -p -s <span style="color:#e6db74">&#39;a={}&#39;</span> <span style="color:#e6db74">&#39;for i in range(10000):  a[i]=i&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">500</span> loops, best of 5: <span style="color:#ae81ff">777</span> usec per loop
</span></span></code></pre></div><ul>
<li><strong>Avoid Function Calling while Initializing Common Objects</strong></li>
</ul>
<p>Unless you have to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ python -m timeit -p <span style="color:#e6db74">&#39;a=[]&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10000000</span> loops, best of 5: 28.7 nsec per loop
</span></span><span style="display:flex;"><span>$ python -m timeit -p <span style="color:#e6db74">&#39;a=list()&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5000000</span> loops, best of 5: 83.3 nsec per loop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ python -m timeit -p <span style="color:#e6db74">&#39;a=()&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">20000000</span> loops, best of 5: <span style="color:#ae81ff">15</span> nsec per loop
</span></span><span style="display:flex;"><span>$ python -m timeit -p <span style="color:#e6db74">&#39;a=tuple()&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5000000</span> loops, best of 5: <span style="color:#ae81ff">45</span> nsec per loop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ python -m timeit -p <span style="color:#e6db74">&#39;a={}&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10000000</span> loops, best of 5: 29.4 nsec per loop
</span></span><span style="display:flex;"><span>$ python -m timeit -p <span style="color:#e6db74">&#39;a=dict()&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5000000</span> loops, best of 5: 77.4 nsec per loop
</span></span></code></pre></div><ul>
<li><strong>Using Tuple as Constant Data Structure</strong></li>
</ul>
<p>Initializing a tuple is cheaper than an equal list:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ python -m timeit -p <span style="color:#e6db74">&#39;a = 1,2,3,4&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">20000000</span> loops, best of 5: 14.8 nsec per loop
</span></span><span style="display:flex;"><span>$ python -m timeit -p <span style="color:#e6db74">&#39;a = [1,2,3,4]&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5000000</span> loops, best of 5: 54.9 nsec per loop
</span></span></code></pre></div><p>OK&hellip; Happy coding with Python!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://xinlin-z.github.io/tags/data-structure/">Data Structure</a></li>
      <li><a href="https://xinlin-z.github.io/tags/algorithm/">Algorithm</a></li>
      <li><a href="https://xinlin-z.github.io/tags/python/">Python</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://xinlin-z.github.io/">Xinlin&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
