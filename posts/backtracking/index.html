<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Backtracking Algorithm | Xinlin&#39;s Blog</title>
<meta name="keywords" content="Algorithm, Backtracking">
<meta name="description" content="Backtracking algorithm is an elegant way to realize nested loop using recursive to search the solution space for your problem, especially for those problems that the depth of nested loop could not be determined beforehand. In this post, I try to demonstrate how to understand and code backtracking algorithm step by step with lots of examples.
What is Backtracking Algorithm?
I would like to think of backtracking algorithm as a search method. Imaging you are in a forest and you need find a way out. There are multiple choices at each intersection, and you have no idea about which direction or path is right. So, you pick out one direction randomly or in any order you like and keep on going. If it is a dead end, you go back and choose another direction, otherwise you find a way out. During the whole process, there might be lots of &ldquo;going back and choosing again&rdquo; moments which is actually the spirit of backtracking.">
<meta name="author" content="">
<link rel="canonical" href="https://xinlin-z.github.io/posts/backtracking/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://xinlin-z.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://xinlin-z.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://xinlin-z.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://xinlin-z.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://xinlin-z.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://xinlin-z.github.io/posts/backtracking/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
    onload="renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
        {left: '\\(', right: '\\)', display: false},
        {left: '\\[', right: '\\]', display: true}
      ],
      throwOnError : false
    });"></script>
<meta property="og:url" content="https://xinlin-z.github.io/posts/backtracking/">
  <meta property="og:site_name" content="Xinlin&#39;s Blog">
  <meta property="og:title" content="Backtracking Algorithm">
  <meta property="og:description" content="Backtracking algorithm is an elegant way to realize nested loop using recursive to search the solution space for your problem, especially for those problems that the depth of nested loop could not be determined beforehand. In this post, I try to demonstrate how to understand and code backtracking algorithm step by step with lots of examples.
What is Backtracking Algorithm? I would like to think of backtracking algorithm as a search method. Imaging you are in a forest and you need find a way out. There are multiple choices at each intersection, and you have no idea about which direction or path is right. So, you pick out one direction randomly or in any order you like and keep on going. If it is a dead end, you go back and choose another direction, otherwise you find a way out. During the whole process, there might be lots of “going back and choosing again” moments which is actually the spirit of backtracking.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-18T20:48:03+12:00">
    <meta property="article:modified_time" content="2025-06-18T20:48:03+12:00">
    <meta property="article:tag" content="Algorithm">
    <meta property="article:tag" content="Backtracking">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Backtracking Algorithm">
<meta name="twitter:description" content="Backtracking algorithm is an elegant way to realize nested loop using recursive to search the solution space for your problem, especially for those problems that the depth of nested loop could not be determined beforehand. In this post, I try to demonstrate how to understand and code backtracking algorithm step by step with lots of examples.
What is Backtracking Algorithm?
I would like to think of backtracking algorithm as a search method. Imaging you are in a forest and you need find a way out. There are multiple choices at each intersection, and you have no idea about which direction or path is right. So, you pick out one direction randomly or in any order you like and keep on going. If it is a dead end, you go back and choose another direction, otherwise you find a way out. During the whole process, there might be lots of &ldquo;going back and choosing again&rdquo; moments which is actually the spirit of backtracking.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://xinlin-z.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Backtracking Algorithm",
      "item": "https://xinlin-z.github.io/posts/backtracking/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Backtracking Algorithm",
  "name": "Backtracking Algorithm",
  "description": "Backtracking algorithm is an elegant way to realize nested loop using recursive to search the solution space for your problem, especially for those problems that the depth of nested loop could not be determined beforehand. In this post, I try to demonstrate how to understand and code backtracking algorithm step by step with lots of examples.\nWhat is Backtracking Algorithm? I would like to think of backtracking algorithm as a search method. Imaging you are in a forest and you need find a way out. There are multiple choices at each intersection, and you have no idea about which direction or path is right. So, you pick out one direction randomly or in any order you like and keep on going. If it is a dead end, you go back and choose another direction, otherwise you find a way out. During the whole process, there might be lots of \u0026ldquo;going back and choosing again\u0026rdquo; moments which is actually the spirit of backtracking.\n",
  "keywords": [
    "Algorithm", "Backtracking"
  ],
  "articleBody": "Backtracking algorithm is an elegant way to realize nested loop using recursive to search the solution space for your problem, especially for those problems that the depth of nested loop could not be determined beforehand. In this post, I try to demonstrate how to understand and code backtracking algorithm step by step with lots of examples.\nWhat is Backtracking Algorithm? I would like to think of backtracking algorithm as a search method. Imaging you are in a forest and you need find a way out. There are multiple choices at each intersection, and you have no idea about which direction or path is right. So, you pick out one direction randomly or in any order you like and keep on going. If it is a dead end, you go back and choose another direction, otherwise you find a way out. During the whole process, there might be lots of “going back and choosing again” moments which is actually the spirit of backtracking.\nIn analogy, backtracking alrorithm is similar to Depth First Search (DFS) algorithm in graph data structure, but in a more general way. There most likely have no clear graph data structure, and you need to figure out a way to treat the solution space of your problem as a graph. The very basic search method is to construct loops, especially nested loop. However, both DFS and backtracking algorithm leveraging the more powerful and flexible recursive way!\nBacktracking algorithm is an efficient way to tackle Constraint Satisfaction Problems (CSP), which means to find out a set of objects whose state must satisfy some kind of constraints or limitations. The objects could be anything, such as paths or numbers, as long as the constraint would be met by them. A very classic example of applying backtracking strategy in textbook is the Eight Queen Puzzle problem (or N-Queen Puzzle in general). Normally, there are more than one solution when applying backtracking algorithm.\nTom is sleeping while I am studying backtracking algorithm\nBacktracking Algorithm Pseudo-Code This is the backbone of backtracking algorithm:\nFunction backtracking(current_state): if current_state is complete and valid: find a solution! return for each step in possible steps according to the current_state: if step is valid (does not violate constraints): add step to current_state backtracking(current_state) remove step from current_state In different scenarios, how to find the possible steps in accordance with valid current state and constraints is the most difficult part while coding.\nExample: Find Out Combinations Suppose the task is to find out all the $2$-element pairs from a set (mathematical set) such as ABCD. The code needs a nested loop with depth of $2$.\n\u003e\u003e\u003e elem = tuple('ABCD') \u003e\u003e\u003e size = len(elem) \u003e\u003e\u003e for i in range(size): ... for j in range(i+1,size): ... print(elem[i], elem[j]) ... A B A C A D B C B D C D If the task is changed to find out all $3$-element combinations. The code should be constructed by a nested loop with depth of $3$.\n\u003e\u003e\u003e elem = tuple('ABCD') \u003e\u003e\u003e size = len(elem) \u003e\u003e\u003e for i in range(size): ... for j in range(i+1,size): ... for k in range(j+1,size): ... print(elem[i], elem[j], elem[k]) ... A B C A B D A C D B C D Now you might see the pattern of the code and the hidden issue. When the size of the set is $N$, the task is to find out all $M$-element combinations and both $N$ and $M$ $(M \u003c= N)$ could not be determined while coding, backtracking algorithm kicks in. By leveraging the power of recursive, backtracking gives us a way to tackle this problem.\nclass comb: def __init__(self, theset): self.set = theset self.N = len(theset) def _backtracking(self, M): # recursive function starts from end condition if len(self.comb) == M: yield self.comb return for i in range(self.ipos, self.N): self.comb.append(self.set[i]) self.ipos = i + 1 # loop starts from next position yield from self._backtracking(M) self.comb.pop() def __call__(self, M): assert 0 \u003c M \u003c= self.N self.ipos = 0 self.comb = [] yield from self._backtracking(M) # generator print('3-element combinations from ABCD:') for c in comb(tuple('ABCD'))(3): print(c) print('2-element combinations from ABC:') for c in comb(tuple('ABC'))(2): print(c) print('4-element combinations from ABCDE:') for c in comb(tuple('ABCDE'))(4): print(c) The output of this piece of code is below:\n3-element combinations from ABCD: ['A', 'B', 'C'] ['A', 'B', 'D'] ['A', 'C', 'D'] ['B', 'C', 'D'] 2-element combinations from ABC: ['A', 'B'] ['A', 'C'] ['B', 'C'] 4-element combinations from ABCDE: ['A', 'B', 'C', 'D'] ['A', 'B', 'C', 'E'] ['A', 'B', 'D', 'E'] ['A', 'C', 'D', 'E'] ['B', 'C', 'D', 'E'] Perfect! Backtracking works… Actually, recursive is more powerful than loop. In this case, whatever $N$ and $M$ could be, we don’t need to change the code anymore. Backtracking is just like Depth First Search (DFS) algorithm for graph structure, but in a more general way.\nThis combination problem has two constraints:\nfixed size of object set no duplicates Example: Find Out Permutation Find out permutation is a bit harder than combination. First of all, I give out the code implemented with nested loop for later comparison. The task is to find out all $2$-element permutation from ABC.\n\u003e\u003e\u003e elem = tuple('ABC') \u003e\u003e\u003e size = len(elem) \u003e\u003e\u003e for i in range(size): ... for j in range(size): ... result = elem[i], elem[j] ... if len(set(result)) == 2: # length without duplicates ... print(result) ... ('A', 'B') ('A', 'C') ('B', 'A') ('B', 'C') ('C', 'A') ('C', 'B') The issue for this code is the same, not flexible enough. When $M$ and $N$ change, the existed code would become useless. Now, I use backtracking trick to solve this issue.\nclass perm: def __init__(self, theset): self.set = theset self.N = len(theset) def _backtracking(self, M): if len(self.perm) == M: yield self.perm return for i in range(0,self.N): if self.set[i] not in self.perm: self.perm.append(self.set[i]) yield from self._backtracking(M) self.perm.pop() def __call__(self, M): assert 0 \u003c M \u003c= self.N self.perm = [] yield from self._backtracking(M) print('1-element permutations from AB:') for c in perm(tuple('AB'))(1): print(c) print('2-element permutations from ABC:') for c in perm(tuple('ABC'))(2): print(c) print('3-element permutations from ABC:') for c in perm(tuple('ABC'))(3): print(c) Output:\n1-element permutations from AB: ['A'] ['B'] 2-element permutations from ABC: ['A', 'B'] ['A', 'C'] ['B', 'A'] ['B', 'C'] ['C', 'A'] ['C', 'B'] 3-element permutations from ABC: ['A', 'B', 'C'] ['A', 'C', 'B'] ['B', 'A', 'C'] ['B', 'C', 'A'] ['C', 'A', 'B'] ['C', 'B', 'A'] Great! The code for permutation is a bit more brutal than for combination. One more constraint compare to combination problem is that the order matters.\nExample: N-Queen Problem On a square $N\\times N$ chessboard, the constraints for N-Queen problem is no two queens threaten each other. So, no two queens should be on the same row, column and diagonal.\nclass NQueen: def __init__(self, N): self.N = N self.chessboard = [[0 for _ in range(N)] for _ in range(N)] def _check_position(self, col): for i in range(self.row): # check vertical line if self.chessboard[i][col] == 1: return False # position offset pos_off = self.row - i # check forward diagonal check_pos = col + pos_off if 0 \u003c= check_pos \u003c self.N: if self.chessboard[i][check_pos] == 1: return False # check backward diagonal check_pos = col - pos_off if 0 \u003c= check_pos \u003c self.N: if self.chessboard[i][check_pos] == 1: return False return True def _backtracking(self): if self.row == self.N: yield self.chessboard return for i in range(self.N): if self._check_position(i) is True: self.chessboard[self.row][i] = 1 self.row += 1 yield from self._backtracking() self.row -= 1 self.chessboard[self.row][i] = 0 def __call__(self): self.row = 0 yield from self._backtracking() for n in (i for i in range(1,6)): print(f'* N-Queen Problem for N={n}') for i,q in enumerate(NQueen(n)(),1): print(f'Solution {i}:') for i in range(n): print(q[i]) Output:\n* N-Queen Problem for N=1 Solution 1: [1] * N-Queen Problem for N=2 * N-Queen Problem for N=3 * N-Queen Problem for N=4 Solution 1: [0, 1, 0, 0] [0, 0, 0, 1] [1, 0, 0, 0] [0, 0, 1, 0] Solution 2: [0, 0, 1, 0] [1, 0, 0, 0] [0, 0, 0, 1] [0, 1, 0, 0] * N-Queen Problem for N=5 Solution 1: [1, 0, 0, 0, 0] [0, 0, 1, 0, 0] [0, 0, 0, 0, 1] [0, 1, 0, 0, 0] [0, 0, 0, 1, 0] Solution 2: [1, 0, 0, 0, 0] [0, 0, 0, 1, 0] [0, 1, 0, 0, 0] [0, 0, 0, 0, 1] [0, 0, 1, 0, 0] Solution 3: [0, 1, 0, 0, 0] [0, 0, 0, 1, 0] [1, 0, 0, 0, 0] [0, 0, 1, 0, 0] [0, 0, 0, 0, 1] Solution 4: [0, 1, 0, 0, 0] [0, 0, 0, 0, 1] [0, 0, 1, 0, 0] [1, 0, 0, 0, 0] [0, 0, 0, 1, 0] Solution 5: [0, 0, 1, 0, 0] [1, 0, 0, 0, 0] [0, 0, 0, 1, 0] [0, 1, 0, 0, 0] [0, 0, 0, 0, 1] Solution 6: [0, 0, 1, 0, 0] [0, 0, 0, 0, 1] [0, 1, 0, 0, 0] [0, 0, 0, 1, 0] [1, 0, 0, 0, 0] Solution 7: [0, 0, 0, 1, 0] [1, 0, 0, 0, 0] [0, 0, 1, 0, 0] [0, 0, 0, 0, 1] [0, 1, 0, 0, 0] Solution 8: [0, 0, 0, 1, 0] [0, 1, 0, 0, 0] [0, 0, 0, 0, 1] [0, 0, 1, 0, 0] [1, 0, 0, 0, 0] Solution 9: [0, 0, 0, 0, 1] [0, 1, 0, 0, 0] [0, 0, 0, 1, 0] [1, 0, 0, 0, 0] [0, 0, 1, 0, 0] Solution 10: [0, 0, 0, 0, 1] [0, 0, 1, 0, 0] [1, 0, 0, 0, 0] [0, 0, 0, 1, 0] [0, 1, 0, 0, 0] Excellent! Interestingly, when $N=2$ and $N=3$, there is no solution.\nComplexity Analysis Time Complexity Backtracking algorithm does not bring down the time complexity, which is the same as the corresponding nested loop method as we can see in the combination example. So, time complexity is still $O(N^M)$, which is also the potential size of solution space. For different problems, the hidden coefficient could be distinct significantly. The earlier to determine the dead ends during backtracking, the more efficient the algorithm. Like the N-Queen example code, in _check_position method, only check the row numbers smaller than current row.\nSpace Complexity Backtracking’s intention is to find solutions by recursive way. There is only some spaces used on calling stack and no intermediate results are explicitly stored during execution. So, we can say the space complexity of backtracking algorithm is the lovely $O(1)$.\nSummary This post introduces the backtracking algorithm as a powerful recursive technique for exploring solution spaces, particularly when the depth of iteration is unknown. It could be conceptualized as a systematic search method, akin to Depth First Search (DFS) in graph theory, where invalid paths are discarded and alternatives are explored. The core pseudo-code illustrates its recursive nature. Practical examples, including finding combinations, permutations, and solving the N-Queen problem, demonstrate its versatility and how it elegantly handles problems where traditional nested loops fall short due to dynamic depth requirements. While backtracking algorithm doesn’t reduce time complexity, it offers a flexible, recursive approach, and its space complexity is generally $O(1)$ due to minimal explicit storage.\n",
  "wordCount" : "1849",
  "inLanguage": "en",
  "datePublished": "2025-06-18T20:48:03+12:00",
  "dateModified": "2025-06-18T20:48:03+12:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://xinlin-z.github.io/posts/backtracking/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Xinlin's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://xinlin-z.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xinlin-z.github.io/" accesskey="h" title="Xinlin&#39;s Blog (Alt + H)">Xinlin&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://xinlin-z.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://xinlin-z.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://xinlin-z.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://xinlin-z.github.io/pages/about" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Backtracking Algorithm
    </h1>
    <div class="post-meta"><span title='2025-06-18 20:48:03 +1200 NZST'>June 18, 2025</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-is-backtracking-algorithm" aria-label="What is Backtracking Algorithm?">What is Backtracking Algorithm?</a></li>
                <li>
                    <a href="#backtracking-algorithm-pseudo-code" aria-label="Backtracking Algorithm Pseudo-Code">Backtracking Algorithm Pseudo-Code</a></li>
                <li>
                    <a href="#example-find-out-combinations" aria-label="Example: Find Out Combinations">Example: Find Out Combinations</a></li>
                <li>
                    <a href="#example-find-out-permutation" aria-label="Example: Find Out Permutation">Example: Find Out Permutation</a></li>
                <li>
                    <a href="#example-n-queen-problem" aria-label="Example: N-Queen Problem">Example: N-Queen Problem</a></li>
                <li>
                    <a href="#complexity-analysis" aria-label="Complexity Analysis">Complexity Analysis</a><ul>
                        
                <li>
                    <a href="#time-complexity" aria-label="Time Complexity">Time Complexity</a></li>
                <li>
                    <a href="#space-complexity" aria-label="Space Complexity">Space Complexity</a></li></ul>
                </li>
                <li>
                    <a href="#summary" aria-label="Summary">Summary</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Backtracking algorithm is an elegant way to realize nested loop using recursive to search the solution space for your problem, especially for those problems that the depth of nested loop could not be determined beforehand. In this post, I try to demonstrate how to understand and code backtracking algorithm step by step with lots of examples.</p>
<h2 id="what-is-backtracking-algorithm">What is Backtracking Algorithm?<a hidden class="anchor" aria-hidden="true" href="#what-is-backtracking-algorithm">#</a></h2>
<p>I would like to think of backtracking algorithm as a search method. Imaging you are in a forest and you need find a way out. There are multiple choices at each intersection, and you have no idea about which direction or path is right. So, you pick out one direction randomly or in any order you like and keep on going. If it is a dead end, you go back and choose another direction, otherwise you find a way out. During the whole process, there might be lots of &ldquo;going back and choosing again&rdquo; moments which is actually the spirit of backtracking.</p>
<p>In analogy, backtracking alrorithm is similar to Depth First Search (DFS) algorithm in graph data structure, but in a more general way. There most likely have no clear graph data structure, and you need to figure out a way to treat the solution space of your problem as a graph. The very basic search method is to construct loops, especially nested loop. However, both DFS and backtracking algorithm leveraging the more powerful and flexible recursive way!</p>
<p>Backtracking algorithm is an efficient way to tackle Constraint Satisfaction Problems (CSP), which means to find out a set of objects whose state must satisfy some kind of constraints or limitations. The objects could be anything, such as paths or numbers, as long as the constraint would be met by them. A very classic example of applying backtracking strategy in textbook is the Eight Queen Puzzle problem (or <a href="#example-n-queen-problem">N-Queen Puzzle</a> in general). Normally, there are more than one solution when applying backtracking algorithm.</p>
<figure>
    <img loading="lazy" src="tom.jpg"
         alt="Tom is sleeping while I am studying backtracking algorithm"/> <figcaption>
            <p>Tom is sleeping while I am studying backtracking algorithm</p>
        </figcaption>
</figure>

<h2 id="backtracking-algorithm-pseudo-code">Backtracking Algorithm Pseudo-Code<a hidden class="anchor" aria-hidden="true" href="#backtracking-algorithm-pseudo-code">#</a></h2>
<p>This is the backbone of backtracking algorithm:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Function backtracking(current_state):
</span></span><span style="display:flex;"><span>    if current_state is complete and valid:
</span></span><span style="display:flex;"><span>        find a solution!
</span></span><span style="display:flex;"><span>        return
</span></span><span style="display:flex;"><span>    for each step in possible steps according to the current_state:
</span></span><span style="display:flex;"><span>        if step is valid (does not violate constraints):
</span></span><span style="display:flex;"><span>            add step to current_state
</span></span><span style="display:flex;"><span>            backtracking(current_state)
</span></span><span style="display:flex;"><span>            remove step from current_state
</span></span></code></pre></div><p>In different scenarios, how to find the possible steps in accordance with valid current state and constraints is the most difficult part while coding.</p>
<h2 id="example-find-out-combinations">Example: Find Out Combinations<a hidden class="anchor" aria-hidden="true" href="#example-find-out-combinations">#</a></h2>
<p>Suppose the task is to find out all the $2$-element pairs from a set (mathematical set) such as ABCD. The code needs a nested loop with depth of $2$.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> elem <span style="color:#f92672">=</span> tuple(<span style="color:#e6db74">&#39;ABCD&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> size <span style="color:#f92672">=</span> len(elem)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(size):
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,size):
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>         print(elem[i], elem[j])
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>         
</span></span><span style="display:flex;"><span>A B
</span></span><span style="display:flex;"><span>A C
</span></span><span style="display:flex;"><span>A D
</span></span><span style="display:flex;"><span>B C
</span></span><span style="display:flex;"><span>B D
</span></span><span style="display:flex;"><span>C D
</span></span></code></pre></div><p>If the task is changed to find out all $3$-element combinations. The code should be constructed by a nested loop with depth of $3$.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> elem <span style="color:#f92672">=</span> tuple(<span style="color:#e6db74">&#39;ABCD&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> size <span style="color:#f92672">=</span> len(elem)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(size):
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,size):
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>         <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,size):
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>             print(elem[i], elem[j], elem[k])
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>             
</span></span><span style="display:flex;"><span>A B C
</span></span><span style="display:flex;"><span>A B D
</span></span><span style="display:flex;"><span>A C D
</span></span><span style="display:flex;"><span>B C D
</span></span></code></pre></div><p>Now you might see the pattern of the code and the hidden issue. When the size of the set is $N$, the task is to find out all $M$-element combinations and both $N$ and $M$ $(M &lt;= N)$ could not be determined while coding, backtracking algorithm kicks in. By leveraging the power of recursive, backtracking gives us a way to tackle this problem.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">comb</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, theset):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>set <span style="color:#f92672">=</span> theset
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>N <span style="color:#f92672">=</span> len(theset)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_backtracking</span>(self, M):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># recursive function starts from end condition</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(self<span style="color:#f92672">.</span>comb) <span style="color:#f92672">==</span> M:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">yield</span> self<span style="color:#f92672">.</span>comb
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>ipos, self<span style="color:#f92672">.</span>N):
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>comb<span style="color:#f92672">.</span>append(self<span style="color:#f92672">.</span>set[i])
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>ipos <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>  <span style="color:#75715e"># loop starts from next position</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">yield from</span> self<span style="color:#f92672">.</span>_backtracking(M)
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>comb<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__call__</span>(self, M):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">assert</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;</span> M <span style="color:#f92672">&lt;=</span> self<span style="color:#f92672">.</span>N
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>ipos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>comb <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">yield from</span> self<span style="color:#f92672">.</span>_backtracking(M)  <span style="color:#75715e"># generator</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;3-element combinations from ABCD:&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> comb(tuple(<span style="color:#e6db74">&#39;ABCD&#39;</span>))(<span style="color:#ae81ff">3</span>):
</span></span><span style="display:flex;"><span>    print(c)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;2-element combinations from ABC:&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> comb(tuple(<span style="color:#e6db74">&#39;ABC&#39;</span>))(<span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>    print(c)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;4-element combinations from ABCDE:&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> comb(tuple(<span style="color:#e6db74">&#39;ABCDE&#39;</span>))(<span style="color:#ae81ff">4</span>):
</span></span><span style="display:flex;"><span>    print(c)
</span></span></code></pre></div><p>The output of this piece of code is below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>3-element combinations from ABCD:
</span></span><span style="display:flex;"><span>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]
</span></span><span style="display:flex;"><span>[&#39;A&#39;, &#39;B&#39;, &#39;D&#39;]
</span></span><span style="display:flex;"><span>[&#39;A&#39;, &#39;C&#39;, &#39;D&#39;]
</span></span><span style="display:flex;"><span>[&#39;B&#39;, &#39;C&#39;, &#39;D&#39;]
</span></span><span style="display:flex;"><span>2-element combinations from ABC:
</span></span><span style="display:flex;"><span>[&#39;A&#39;, &#39;B&#39;]
</span></span><span style="display:flex;"><span>[&#39;A&#39;, &#39;C&#39;]
</span></span><span style="display:flex;"><span>[&#39;B&#39;, &#39;C&#39;]
</span></span><span style="display:flex;"><span>4-element combinations from ABCDE:
</span></span><span style="display:flex;"><span>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]
</span></span><span style="display:flex;"><span>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;E&#39;]
</span></span><span style="display:flex;"><span>[&#39;A&#39;, &#39;B&#39;, &#39;D&#39;, &#39;E&#39;]
</span></span><span style="display:flex;"><span>[&#39;A&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]
</span></span><span style="display:flex;"><span>[&#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]
</span></span></code></pre></div><p>Perfect! Backtracking works&hellip; Actually, recursive is more powerful than loop. In this case, whatever $N$ and $M$ could be, we don&rsquo;t need to change the code anymore. Backtracking is just like Depth First Search (DFS) algorithm for graph structure, but in a more general way.</p>
<p>This combination problem has two constraints:</p>
<ul>
<li>fixed size of object set</li>
<li>no duplicates</li>
</ul>
<h2 id="example-find-out-permutation">Example: Find Out Permutation<a hidden class="anchor" aria-hidden="true" href="#example-find-out-permutation">#</a></h2>
<p>Find out permutation is a bit harder than combination. First of all, I give out the code implemented with nested loop for later comparison. The task is to find out all $2$-element permutation from ABC.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> elem <span style="color:#f92672">=</span> tuple(<span style="color:#e6db74">&#39;ABC&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> size <span style="color:#f92672">=</span> len(elem)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(size):    
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(size):
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>         result <span style="color:#f92672">=</span> elem[i], elem[j]
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>         <span style="color:#66d9ef">if</span> len(set(result)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>:  <span style="color:#75715e"># length without duplicates</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>             print(result)
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span> 
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;A&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;A&#39;</span>, <span style="color:#e6db74">&#39;C&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;A&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;C&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;C&#39;</span>, <span style="color:#e6db74">&#39;A&#39;</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#e6db74">&#39;C&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>)
</span></span></code></pre></div><p>The issue for this code is the same, not flexible enough. When $M$ and $N$ change, the existed code would become useless. Now, I use backtracking trick to solve this issue.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">perm</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, theset):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>set <span style="color:#f92672">=</span> theset
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>N <span style="color:#f92672">=</span> len(theset)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_backtracking</span>(self, M):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(self<span style="color:#f92672">.</span>perm) <span style="color:#f92672">==</span> M:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">yield</span> self<span style="color:#f92672">.</span>perm
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>,self<span style="color:#f92672">.</span>N):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>set[i] <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>perm:
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>perm<span style="color:#f92672">.</span>append(self<span style="color:#f92672">.</span>set[i])
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">yield from</span> self<span style="color:#f92672">.</span>_backtracking(M)
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>perm<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__call__</span>(self, M):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">assert</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;</span> M <span style="color:#f92672">&lt;=</span> self<span style="color:#f92672">.</span>N
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>perm <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">yield from</span> self<span style="color:#f92672">.</span>_backtracking(M)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;1-element permutations from AB:&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> perm(tuple(<span style="color:#e6db74">&#39;AB&#39;</span>))(<span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    print(c)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;2-element permutations from ABC:&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> perm(tuple(<span style="color:#e6db74">&#39;ABC&#39;</span>))(<span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>    print(c)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;3-element permutations from ABC:&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> perm(tuple(<span style="color:#e6db74">&#39;ABC&#39;</span>))(<span style="color:#ae81ff">3</span>):
</span></span><span style="display:flex;"><span>    print(c)
</span></span></code></pre></div><p>Output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>1-element permutations from AB:
</span></span><span style="display:flex;"><span>[&#39;A&#39;]
</span></span><span style="display:flex;"><span>[&#39;B&#39;]
</span></span><span style="display:flex;"><span>2-element permutations from ABC:
</span></span><span style="display:flex;"><span>[&#39;A&#39;, &#39;B&#39;]
</span></span><span style="display:flex;"><span>[&#39;A&#39;, &#39;C&#39;]
</span></span><span style="display:flex;"><span>[&#39;B&#39;, &#39;A&#39;]
</span></span><span style="display:flex;"><span>[&#39;B&#39;, &#39;C&#39;]
</span></span><span style="display:flex;"><span>[&#39;C&#39;, &#39;A&#39;]
</span></span><span style="display:flex;"><span>[&#39;C&#39;, &#39;B&#39;]
</span></span><span style="display:flex;"><span>3-element permutations from ABC:
</span></span><span style="display:flex;"><span>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]
</span></span><span style="display:flex;"><span>[&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]
</span></span><span style="display:flex;"><span>[&#39;B&#39;, &#39;A&#39;, &#39;C&#39;]
</span></span><span style="display:flex;"><span>[&#39;B&#39;, &#39;C&#39;, &#39;A&#39;]
</span></span><span style="display:flex;"><span>[&#39;C&#39;, &#39;A&#39;, &#39;B&#39;]
</span></span><span style="display:flex;"><span>[&#39;C&#39;, &#39;B&#39;, &#39;A&#39;]
</span></span></code></pre></div><p>Great! The code for permutation is a bit more brutal than for combination. One more constraint compare to combination problem is that the order matters.</p>
<h2 id="example-n-queen-problem">Example: N-Queen Problem<a hidden class="anchor" aria-hidden="true" href="#example-n-queen-problem">#</a></h2>
<p>On a square $N\times N$ chessboard, the constraints for N-Queen problem is no two queens threaten each other. So, no two queens should be on the same row, column and diagonal.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NQueen</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, N):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>N <span style="color:#f92672">=</span> N
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>chessboard <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span> <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(N)] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(N)]
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_check_position</span>(self, col):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>row):
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># check vertical line</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>chessboard[i][col] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># position offset</span>
</span></span><span style="display:flex;"><span>            pos_off <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>row <span style="color:#f92672">-</span> i
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># check forward diagonal</span>
</span></span><span style="display:flex;"><span>            check_pos <span style="color:#f92672">=</span> col <span style="color:#f92672">+</span> pos_off
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> check_pos <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>N:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>chessboard[i][check_pos] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># check backward diagonal</span>
</span></span><span style="display:flex;"><span>            check_pos <span style="color:#f92672">=</span> col <span style="color:#f92672">-</span> pos_off
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> check_pos <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>N:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>chessboard[i][check_pos] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_backtracking</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>row <span style="color:#f92672">==</span> self<span style="color:#f92672">.</span>N:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">yield</span> self<span style="color:#f92672">.</span>chessboard
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>N):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>_check_position(i) <span style="color:#f92672">is</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>chessboard[self<span style="color:#f92672">.</span>row][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>row <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">yield from</span> self<span style="color:#f92672">.</span>_backtracking()
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>row <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>chessboard[self<span style="color:#f92672">.</span>row][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__call__</span>(self):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>row <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">yield from</span> self<span style="color:#f92672">.</span>_backtracking()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> (i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">6</span>)):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;* N-Queen Problem for N=</span><span style="color:#e6db74">{</span>n<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i,q <span style="color:#f92672">in</span> enumerate(NQueen(n)(),<span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Solution </span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">:&#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>            print(q[i])
</span></span></code></pre></div><p>Output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>* N-Queen Problem for N=1
</span></span><span style="display:flex;"><span>Solution 1:
</span></span><span style="display:flex;"><span>[1]
</span></span><span style="display:flex;"><span>* N-Queen Problem for N=2
</span></span><span style="display:flex;"><span>* N-Queen Problem for N=3
</span></span><span style="display:flex;"><span>* N-Queen Problem for N=4
</span></span><span style="display:flex;"><span>Solution 1:
</span></span><span style="display:flex;"><span>[0, 1, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 1]
</span></span><span style="display:flex;"><span>[1, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 1, 0]
</span></span><span style="display:flex;"><span>Solution 2:
</span></span><span style="display:flex;"><span>[0, 0, 1, 0]
</span></span><span style="display:flex;"><span>[1, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 1]
</span></span><span style="display:flex;"><span>[0, 1, 0, 0]
</span></span><span style="display:flex;"><span>* N-Queen Problem for N=5
</span></span><span style="display:flex;"><span>Solution 1:
</span></span><span style="display:flex;"><span>[1, 0, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 1, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 0, 1]
</span></span><span style="display:flex;"><span>[0, 1, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 1, 0]
</span></span><span style="display:flex;"><span>Solution 2:
</span></span><span style="display:flex;"><span>[1, 0, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 1, 0]
</span></span><span style="display:flex;"><span>[0, 1, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 0, 1]
</span></span><span style="display:flex;"><span>[0, 0, 1, 0, 0]
</span></span><span style="display:flex;"><span>Solution 3:
</span></span><span style="display:flex;"><span>[0, 1, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 1, 0]
</span></span><span style="display:flex;"><span>[1, 0, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 1, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 0, 1]
</span></span><span style="display:flex;"><span>Solution 4:
</span></span><span style="display:flex;"><span>[0, 1, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 0, 1]
</span></span><span style="display:flex;"><span>[0, 0, 1, 0, 0]
</span></span><span style="display:flex;"><span>[1, 0, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 1, 0]
</span></span><span style="display:flex;"><span>Solution 5:
</span></span><span style="display:flex;"><span>[0, 0, 1, 0, 0]
</span></span><span style="display:flex;"><span>[1, 0, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 1, 0]
</span></span><span style="display:flex;"><span>[0, 1, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 0, 1]
</span></span><span style="display:flex;"><span>Solution 6:
</span></span><span style="display:flex;"><span>[0, 0, 1, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 0, 1]
</span></span><span style="display:flex;"><span>[0, 1, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 1, 0]
</span></span><span style="display:flex;"><span>[1, 0, 0, 0, 0]
</span></span><span style="display:flex;"><span>Solution 7:
</span></span><span style="display:flex;"><span>[0, 0, 0, 1, 0]
</span></span><span style="display:flex;"><span>[1, 0, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 1, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 0, 1]
</span></span><span style="display:flex;"><span>[0, 1, 0, 0, 0]
</span></span><span style="display:flex;"><span>Solution 8:
</span></span><span style="display:flex;"><span>[0, 0, 0, 1, 0]
</span></span><span style="display:flex;"><span>[0, 1, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 0, 1]
</span></span><span style="display:flex;"><span>[0, 0, 1, 0, 0]
</span></span><span style="display:flex;"><span>[1, 0, 0, 0, 0]
</span></span><span style="display:flex;"><span>Solution 9:
</span></span><span style="display:flex;"><span>[0, 0, 0, 0, 1]
</span></span><span style="display:flex;"><span>[0, 1, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 1, 0]
</span></span><span style="display:flex;"><span>[1, 0, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 1, 0, 0]
</span></span><span style="display:flex;"><span>Solution 10:
</span></span><span style="display:flex;"><span>[0, 0, 0, 0, 1]
</span></span><span style="display:flex;"><span>[0, 0, 1, 0, 0]
</span></span><span style="display:flex;"><span>[1, 0, 0, 0, 0]
</span></span><span style="display:flex;"><span>[0, 0, 0, 1, 0]
</span></span><span style="display:flex;"><span>[0, 1, 0, 0, 0]
</span></span></code></pre></div><p>Excellent! Interestingly, when $N=2$ and $N=3$, there is no solution.</p>
<h2 id="complexity-analysis">Complexity Analysis<a hidden class="anchor" aria-hidden="true" href="#complexity-analysis">#</a></h2>
<h3 id="time-complexity">Time Complexity<a hidden class="anchor" aria-hidden="true" href="#time-complexity">#</a></h3>
<p>Backtracking algorithm does not bring down the time complexity, which is the same as the corresponding nested loop method as we can see in the combination example. So, time complexity is still $O(N^M)$, which is also the potential size of solution space. For different problems, the hidden coefficient could be distinct significantly. The earlier to determine the dead ends during backtracking, the more efficient the algorithm. Like the N-Queen example code, in <code>_check_position</code> method, only check the row numbers smaller than current row.</p>
<h3 id="space-complexity">Space Complexity<a hidden class="anchor" aria-hidden="true" href="#space-complexity">#</a></h3>
<p>Backtracking&rsquo;s intention is to find solutions by recursive way. There is only some spaces used on calling stack and no intermediate results are explicitly stored during execution. So, we can say the space complexity of backtracking algorithm is the lovely $O(1)$.</p>
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>This post introduces the backtracking algorithm as a powerful recursive technique for exploring solution spaces, particularly when the depth of iteration is unknown. It could be conceptualized as a systematic search method, akin to Depth First Search (DFS) in graph theory, where invalid paths are discarded and alternatives are explored. The core pseudo-code illustrates its recursive nature. Practical examples, including finding combinations, permutations, and solving the N-Queen problem, demonstrate its versatility and how it elegantly handles problems where traditional nested loops fall short due to dynamic depth requirements. While backtracking algorithm doesn&rsquo;t reduce time complexity, it offers a flexible, recursive approach, and its space complexity is generally $O(1)$ due to minimal explicit storage.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://xinlin-z.github.io/tags/algorithm/">Algorithm</a></li>
      <li><a href="https://xinlin-z.github.io/tags/backtracking/">Backtracking</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://xinlin-z.github.io/">Xinlin&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
